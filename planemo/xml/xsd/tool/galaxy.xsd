<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gxdocs="http://galaxyproject.org/xml/1.0"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified"
    >
  <xs:annotation>
    <xs:appinfo>Galaxy Schema</xs:appinfo>
    <xs:documentation xml:lang="en">A Galaxy XML tool wrapper</xs:documentation>
  </xs:annotation>

  <xs:element name="tool">
    <xs:annotation gxdocs:best_practices="tools">
      <xs:documentation xml:lang="en"><![CDATA[
The outer-most tag set of tool XML files. Attributes on this tag apply to the
tool as a whole.

### Examples

A normal tool:

```xml
<tool id="seqtk_seq"
      name="Convert FASTQ to FASTA"
      version="1.0.0"
      profile="16.04"
>
```

A ``data_source`` tool contains a few more relevant attributes.

```xml
<tool id="ucsc_table_direct1"
      name="UCSC Main"
      version="1.0.0"
      hidden="false"
      profile="16.01"
      tool_type="data_source"
      URL_method="post">
```
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:all>
        <!-- TODO: Move the anyType further into macros def... -->
        <xs:element name="macros" type="xs:anyType" minOccurs="0"/>
        <xs:element name="edam_topics" type="EdamTopics" minOccurs="0"/>
        <xs:element name="edam_operations" type="EdamOperations" minOccurs="0"/>
        <xs:element name="requirements" type="Requirements" minOccurs="0"/>
        <xs:element name="description" type="xs:string" minOccurs="0">
          <xs:annotation gxdocs:best_practices="tool-descriptions">
            <xs:documentation xml:lang="en"><![CDATA[The value is displayed in
the tool menu immediately following the hyperlink for the tool (based on the
``name`` attribute of the ``<tool>`` tag set described above).

### Example

```xml
<description>table browser</description>
```
]]></xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="parallelism" type="Parallelism" minOccurs="0"/>
        <xs:element name="version_command" type="VersionCommand" minOccurs="0">
        </xs:element>
        <xs:element name="action" type="ToolAction" minOccurs="0" maxOccurs="1" />
        <xs:element name="environment_variables" type="EnvironmentVariables" minOccurs="0" maxOccurs="1"/>
        <xs:element name="command" type="Command"/>
        <xs:element name="request_parameter_translation" type="RequestParameterTranslation" minOccurs="0"/>
        <xs:element name="configfiles" type="ConfigFiles" minOccurs="0"/>
        <xs:element name="outputs" type="Outputs" minOccurs="0"/>
        <xs:element name="inputs" type="Inputs" minOccurs="0"/>
        <xs:element name="tests" type="Tests" minOccurs="0"/>
        <xs:element name="stdio" type="Stdio" minOccurs="0"/>
        <xs:element name="help" type="xs:string" minOccurs="0">
          <xs:annotation gxdocs:best_practices="help-tag">
            <xs:documentation xml:lang="en"><![CDATA[This tag set includes all of the necessary details of how to use the tool. This tag set should be included as the next to the last tag set, before citations, in the tool config. Tool help is written in reStructuredText. Included here is only an overview of a subset of features. For more information see http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html .

tag | details
--- | -------
``.. class:: warningmark`` | a yellow warning symbol
``.. class:: infomark`` | a blue information symbol
``.. image:: path-of-the-file.png :height: 500 :width: 600`` | insert a png file of height 500 and width 600 at this position |
``**bold**`` | bold
``*italic*`` | italic
``*`` | list
``-`` | list
``::`` | paragraph
``-----`` | a horizontal line

### Examples

Show a warning sign to remind users that this tool accept fasta format files only, followed by an example of the query sequence and a figure.

```xml
<help>

.. class:: warningmark

'''TIP''' This tool requires *fasta* format.

----

'''Example'''

Query sequence::
    >seq1
    ATCG...

.. image:: my_figure.png
    :height: 500
    :width: 600

</help>
```

]]></xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="code" type="Code" minOccurs="0"/>
        <xs:element name="uihints" type="UIhints" minOccurs="0"/>
        <xs:element name="options" type="Options" minOccurs="0"/>
        <xs:element name="trackster_conf" type="TracksterConf" minOccurs="0"/>
        <xs:element name="citations" type="Citations" minOccurs="0"/>
      </xs:all>
      <xs:attribute name="id" type="xs:string" use="required">
        <xs:annotation gxdocs:best_practices="tool-ids">
          <xs:documentation xml:lang="en">Must be unique across all tools;
should be lowercase and contain only letters, numbers, and underscores.
It allows for tool versioning and metrics of the number of times a tool is used,
among other things.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string" use="required">
        <xs:annotation gxdocs:best_practices="tool-names">
          <xs:documentation xml:lang="en">This string is what is displayed as a
hyperlink in the tool menu.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="version" type="xs:string" default="1.0.0">
        <xs:annotation gxdocs:best_practices="tool-versions">
          <xs:documentation xml:lang="en">This string defaults to ``1.0.0`` if it is not
included in the tag. It allows for tool versioning and should be increased with each new version
of the tool.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="hidden" type="PermissiveBoolean" default="false">
        <xs:annotation>
          <xs:documentation xml:lang="en">Allows for tools to be loaded upon
server startup, but not displayed in the tool menu. This attribute should be
applied in the toolbox configuration instead and so should be considered
deprecated.
</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="display_interface" type="PermissiveBoolean">
        <xs:annotation>
          <xs:documentation xml:lang="en">Disable the display the tool's
graphical tool form by setting this to ``false``.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="tool_type" type="ToolTypeType">
        <xs:annotation>
          <xs:documentation xml:lang="en">Allows for certain framework
functionality to be performed on certain types of tools. Normal tools that execute
typical command-line jobs do not need to specify this, special kinds of tools such
as [Data Source](https://wiki.galaxyproject.org/Admin/Internals/DataSources) and
[Data Manager](https://wiki.galaxyproject.org/Admin/Tools/DataManagers) tools should
set this to have values such as ``data_source`` or ``manage_data``.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="profile" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">This string specified the minimum Galaxy
version that should be required to run this tool. Certain legacy behaviors such
as using standard error content to detect errors instead of exit code are disabled
automatically if profile is set to any version newer than ``16.01``, such as
``16.04``.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="workflow_compatible" type="xs:boolean" default="true">
        <xs:annotation>
          <xs:documentation xml:lang="en">This attribute indicates if
this tool is usable within a workflow (defaults to ``true`` for normal tools and
``false`` for data sources).</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="URL_method" type="URLmethodType">
        <xs:annotation>
          <xs:documentation xml:lang="en">Only used if ``tool_type`` attribute value
is ``data_source`` - this attribute defines the HTTP request method to use when
communicating with an external data source application (the default is ``get``).</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="ToolAction">
    <xs:annotation>
      <xs:documentation xml:lang="en">Describe the backend Python action to execute for this Galaxy tool.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="module" type="xs:string" use="required">
    </xs:attribute>
    <xs:attribute name="class" type="xs:string" use="required">
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Requirements">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This is a container tag set for the ``requirement`` and ``container`` tags
described in greater detail below. ``requirement``s describe software packages
and other individual computing requirements required to execute a tool, while
``container``s describe Docker containers that should be able to serve as
complete descriptions of the runtime of a tool.

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="requirement" type="Requirement" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="container" type="Container" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="Requirement">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set is contained within the ``requirements`` tag set. Third party
programs or modules that the tool depends upon are included in this tag set.

When a tool runs, Galaxy attempts to *resolve* these requirements (also called
dependencies). ``requirement``s are meant to be abstract and resolvable by
multiple different systems (e.g. [conda](http://conda.pydata.org/docs/), the
[Galaxy Tool Shed dependency management system](https://wiki.galaxyproject.org/ToolShedToolFeatures#Automatic_third-party_tool_dependency_installation_and_compilation_with_installed_repositories),
or [environment modules](http://modules.sourceforge.net/)).

Read more about dependency resolvers in Galaxy on
[docs.galaxyproject.org](https://docs.galaxyproject.org/en/master/admin/dependency_resolvers.html).
The current best practice for tool dependencies is to target Conda, this is
discussed in greater detail
[here](https://docs.galaxyproject.org/en/master/admin/conda_faq.html).

### Examples

This example shows a tool that requires the samtools 0.0.18 package.

This package is available via the Tool Shed (see
[Tool Shed dependency management](https://wiki.galaxyproject.org/ToolShedToolFeatures#Automatic_third-party_tool_dependency_installation_and_compilation_with_installed_repositories)
) as well as [Conda](https://docs.galaxyproject.org/en/master/admin/conda_faq.html)
and can be configured locally to adapt to any other package management system.

```xml
<requirements>
    <requirement type="package" version="0.1.18">samtools</requirement>
</requirements>
```

This older example shows a tool that requires R version 2.15.1. The
``tool_depensencies.xml`` should contain matching declarations for Galaxy to
actually install the R runtime. The ``set_envirornment`` type is only respected
by the tool shed and is ignored by the newer and preferred conda dependency
resolver.

```xml
<requirements>
    <requirement type="set_environment">R_SCRIPT_PATH</requirement>
    <requirement type="package" version="2.15.1">R</requirement>
</requirements>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="RequirementType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"> This value defines the which type of the 3rd party module required by this tool. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="version" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"> For package type requirements this value defines a specific version of the tool dependency. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="Container">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set is contained within the 'requirements' tag set. Galaxy can be
configured to run tools within Docker (https://www.docker.com/) containers -
this tag allows the tool to suggest possible valid Docker containers for this
tool.

Read more about configuring Galaxy to run Docker jobs
[here](https://wiki.galaxyproject.org/Admin/Tools/Docker).

]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="ContainerType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"> This value describes the type of container that the tool may be executed in and currently must be 'docker'. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="Parallelism">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for Parallelism</xs:documentation>
    </xs:annotation>
    <xs:attribute name="method" type="MethodType">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for method</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="merge_outputs" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for merge_outputs</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="split_inputs" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">A comma separated list of data inputs to split for job parallelization.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="split_size" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for split_size</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="split_mode" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for split_mode</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shared_inputs" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">A comma separated list of data inputs that should not be split for this tool, Galaxy will infer this if not present and so this potentially never needs to be set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Code">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
**Deprecated** do not use this unless absolutely necessary.

This tag set provides detailed control of the way the tool is executed. This
(optional) code can be deployed in a separate file in the same directory as the
tool's config file. These hooks are being replaced by new tool config features
and methods in the ~/lib/galaxy/tools/__init__.py code file.

### Examples

#### Dynamic Options

Use associated dynamic select lists where selecting an option in the first
select list dynamically re-renders the options in the second select list. In
this example, we are populating both dynamic select lists from metadata elements
associated with a tool's single input dataset. The 2 metadata elements we're
using look like this.

```python
MetadataElement( name="field_names", default=[], desc="Field names", readonly=True, optional=True, visible=True, no_value=[] )
# The keys in the field_components map to the list of field_names in the above element
# which ensures order for select list options that are built from it.
MetadataElement( name="field_components", default={}, desc="Field names and components", readonly=True, optional=True, visible=True, no_value={} )
```

Our tool config includes a code file tag like this.

```xml
<code file="tool_form_utils.py" />
```

Here are the relevant input parameters in our tool config. The first parameter
is the input dataset that includes the above metadata elements.

```xml
<param name="input" type="data" format="vtkascii,vtkbinary" label="Shape with uncolored surface field">
    <validator type="expression" message="Shape must have an uncolored surface field.">value is not None and len(value.metadata.field_names) > 0</validator>
</param>
```

The following parameter dynamically renders a select list consisting of the
elements in the ``field_names`` metadata element associated with the selected
input dataset.

```xml
<param name="field_name" type="select" label="Field name" refresh_on_change="True">
    <options>
        <filter type="data_meta" ref="input" key="field_names"/>
        <validator type="no_options" message="The selected shape has no uncolored surface fields." />
    </options>
</param>
```

The following parameter calls the ``get_field_components_options()`` function in
the ``tool_form_utils.py`` code file discussed above. This function returns the
value of the input dataset's ``field_components`` metadata element dictionary
whose key is the currently selected ``field_name`` from the select list parameter
above.

```xml
<param name="field_component_index" type="select" label="Field component index" dynamic_options="get_field_components_options(input, field_name=field_name)" help="Color will be applied to the selected field's component associated with this index." />
```

Changing the selected option in the ``field_name`` select list will dynamically
re-render the options available in the associated ``field_component_index`` select
list, which is the behavior we want.

The ``get_field_components_options()`` method looks like this.

```python
def get_field_components_options( dataset, field_name ):
    options = []
    if dataset.metadata is None:
        return options
    if not hasattr( dataset.metadata, 'field_names' ):
        return options
    if dataset.metadata.field_names is None:
        return options
    if field_name is None:
        # The expression validator that helps populate the select list of input
        # datsets in the icqsol_color_surface_field tool does not filter out
        # datasets with no field field_names, so we need this check.
        if len( dataset.metadata.field_names ) == 0:
            return options
        field_name = dataset.metadata.field_names[0]
    field_components = dataset.metadata.field_components.get( field_name, [] )
    for i, field_component in enumerate( field_components ):
        options.append( ( field_component, field_component, i == 0 ) )
    return options
```

]]></xs:documentation>

    </xs:annotation>
    <xs:attribute name="file" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value is the name of the executable code file, and is called in the exec_before_process(), exec_before_job(), exec_after_process() and exec_after_job()( methods.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="UIhints">
    <xs:annotation>
      <xs:documentation xml:lang="en">Used only for data source tools, this directive contains UI options (currently only ``minwidth`` is valid).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="minwidth" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for minwidth</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Options">
    <xs:annotation>
      <xs:documentation xml:lang="en">This directive is used to specify some rarely modified options.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="refresh" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Deprecated, likely unused attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sanitize" type="PermissiveBoolean" default="true">
      <xs:annotation>
        <xs:documentation xml:lang="en">This attribute can be used to turn off all input sanitization for a tool.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="TracksterConf">
    <xs:annotation>
      <xs:documentation xml:lang="en">This directive is used to specify some rarely modified trackster options.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="action" type="TracksterAction" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="TracksterAction">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="output_name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Tests">
    <xs:annotation gxdocs:best_practices="tests">
      <xs:documentation xml:lang="en"><![CDATA[

Container tag set to specify tests via the <test> tag sets. Any number of tests can be included,
and each test is wrapped within separate <test> tag sets. Functional tests are
executed via [Planemo](https://planemo.readthedocs.io/) or the
[run_tests.sh](https://github.com/galaxyproject/galaxy/blob/dev/run_tests.sh)
shell script distributed with Galaxy.

The documentation contained here is mostly reference documentation, for
tutorials on writing tool tests please check out Planemo's
[Test-Driven Development](https://planemo.readthedocs.io/en/latest/writing_advanced.html#test-driven-development)
documentation or the much older wiki content for
[WritingTests](https://wiki.galaxyproject.org/Admin/Tools/WritingTests).

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="test" type="Test" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="Test">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set contains the necessary parameter values for executing the tool via
the functional test framework.

### Example

The following two tests will execute the
[/tools/filters/sorter.xml](https://github.com/galaxyproject/galaxy/blob/dev/tools/filters/sorter.xml)
tool. Notice the way that the tool's inputs and outputs are defined.

```xml
  <tests>
    <test>
      <param name="input" value="1.bed" ftype="bed" />
      <param name="column" value="1"/>
      <param name="order" value="ASC"/>
      <param name="style" value="num"/>
      <output name="out_file1" file="sort1_num.bed" ftype="bed" />
    </test>
    <test>
      <param name="input" value="7.bed" ftype="bed" />
      <param name="column" value="1"/>
      <param name="order" value="ASC"/>
      <param name="style" value="alpha"/>
      <output name="out_file1" file="sort1_alpha.bed" ftype="bed" />
    </test>
  </tests>
```

The following example, tests the execution of the MAF-to-FASTA converter
([/tools/maf/maf_to_fasta.xml](https://github.com/galaxyproject/galaxy/blob/master/tools/maf/maf_to_fasta.xml)).

```xml
<tests>
    <test>
        <param name="input1" value="3.maf" ftype="maf"/>
        <param name="species" value="canFam1"/>
        <param name="fasta_type" value="concatenated"/>
        <output name="out_file1" file="cf_maf2fasta_concat.dat" ftype="fasta"/>
    </test>
</tests>
```

This test demonstrates verifying specific properties about a test output instead
of directly comparing it to another file. Here the file attribute is not
specified and instead a series of assertions is made about the output.

```xml
<test>
    <param name="input" value="maf_stats_interval_in.dat" />
    <param name="lineNum" value="99999"/>
    <output name="out_file1">
        <assert_contents>
            <has_text text="chr7" />
            <not_has_text text="chr8" />
            <has_text_matching expression="1274\d+53" />
            <has_line_matching expression=".*\s+127489808\s+127494553" />
            <!-- &#009; is XML escape code for tab -->
            <has_line line="chr7&#009;127471195&#009;127489808" />
            <has_n_columns n="3" />
        </assert_contents>
    </output>
</test>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="expect_exit_code" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Describe the job's expected exit code.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expect_num_outputs" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Assert the number of outputs this test
should produce, this is useful to ensure ``filter`` directives are implemented correctly.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expect_failure" type="PermissiveBoolean" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en">Setting this to ``true`` indicates
the expectation is for the job fail. If set to ``true`` no job output checks may
be present in ``test`` definition.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxseconds" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Maximum amount of time to let test run.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="TestParamElement">
    <xs:choice>
      <xs:element name="param" type="TestParam" />
      <xs:element name="repeat" type="TestRepeat" />
      <xs:element name="conditional" type="TestConditional" />
      <xs:element name="section" type="TestSection" />
      <xs:element name="output" type="TestOutput" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="output_collection" type="TestOutputCollection"/>
      <xs:element name="assert_command" type="TestAssertions">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the job's
generated command-line.

$assertions
</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="assert_stdout" type="TestAssertions">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the job's
standard output.

$assertions
</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="assert_stderr" type="TestAssertions">
        <xs:annotation>
          <xs:documentation xml:lang="en">Describe assertions about the job's
standard error.

$assertions
</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="TestSection">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

Specify test parameters below a named of a ``section`` block matching
one in ``inputs`` with this element.

``param`` elements in a ``test`` block can be arranged into nested ``repeat``,
``conditional``, and ``select`` structures to match the inputs. While this might
be overkill for simple tests, it helps prevent ambiguous definitions and keeps
things organized in large test cases. A future ``profile`` version of Galaxy
tools may require ``section`` blocks be explicitly defined with this
directive.

### Examples

The test tool demonstrating sections
([section.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/section.xml))
contains a test case demonstrating this block. This test case appears below:

```xml
<test>
    <section name="int">
        <param name="inttest" value="12456" />
    </section>
    <section name="float">
        <param name="floattest" value="6.789" />
    </section>
    <output name="out_file1">
        <assert_contents>
            <has_line line="12456" />
            <has_line line="6.789" />
        </assert_contents>
    </output>
</test>
```

]]>
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must match the name of the
associated input ``section``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestConditional">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

Specify test parameters below a named of a ``conditional`` block matching
one in ``inputs`` with this element.

``param`` elements in a ``test`` block can be arranged into nested ``repeat``,
``conditional``, and ``select`` structures to match the inputs. While this might
be overkill for simple tests, it helps prevent ambiguous definitions and keeps
things organized in large test cases. A future ``profile`` version of Galaxy
tools may require ``conditional`` blocks be explicitly defined with this
directive.

### Examples

The following example demonstrates disambiguation of a parameter (named ``use``)
which appears in multiple ``param`` names in ``conditional``s in the ``inputs``
definition of the [disambiguate_cond.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/disambiguate_cond.xml)
tool.

```xml
<!-- Can use nested conditional blocks as shown below to disambiguate
     various nested parameters. -->
<test>
    <conditional name="p1">
        <param name="use" value="False"/>
    </conditional>
    <conditional name="p2">
        <param name="use" value="True"/>
    </conditional>
    <conditional name="p3">
        <param name="use" value="False"/>
    </conditional>
    <conditional name="files">
        <param name="attach_files" value="True" />
        <conditional name="p4">
            <param name="use" value="True"/>
            <param name="file" value="simple_line_alternative.txt" />
        </conditional>
    </conditional>
    <output name="out_file1">
        <assert_contents>
            <has_line line="7 4 7" />
            <has_line line="This is a different line of text." />
        </assert_contents>
    </output>
</test>
```

The [tophat2](https://github.com/galaxyproject/tools-devteam/blob/master/tools/tophat2/tophat2_wrapper.xml)
tool demonstrates a real tool that benefits from more structured test cases
using the ``conditional`` test directive. One such test case from that tool is
shown below.

```xml
<!-- Test base-space paired-end reads with user-supplied reference fasta and full parameters -->
<test>
    <!-- TopHat commands:
    tophat2 -o tmp_dir -r 20 -p 1 -a 8 -m 0 -i 70 -I 500000 -g 40 +coverage-search +min-coverage-intron 50 +max-coverage-intro 20000 +segment-mismatches 2 +segment-length 25 +microexon-search +report_discordant_pairs tophat_in1 test-data/tophat_in2.fastqsanger test-data/tophat_in3.fastqsanger
    Replace the + with double-dash
    Rename the files in tmp_dir appropriately
    -->
    <conditional name="singlePaired">
      <param name="sPaired" value="paired"/>
      <param name="input1" ftype="fastqsanger" value="tophat_in2.fastqsanger"/>
      <param name="input2" ftype="fastqsanger" value="tophat_in3.fastqsanger"/>
      <param name="mate_inner_distance" value="20"/>
      <param name="report_discordant_pairs" value="Yes" />
    </conditional>
    <param name="genomeSource" value="indexed"/>
    <param name="index" value="tophat_test"/>
    <conditional name="params">
      <param name="settingsType" value="full"/>
      <param name="library_type" value="FR Unstranded"/>
      <param name="read_mismatches" value="5"/>
      <!-- Error: the read mismatches (5) and the read gap length (2) should be less than or equal to the read edit dist (2) -->
      <param name="read_edit_dist" value="5" />
      <param name="bowtie_n" value="Yes"/>
      <param name="mate_std_dev" value="20"/>
      <param name="anchor_length" value="8"/>
      <param name="splice_mismatches" value="0"/>
      <param name="min_intron_length" value="70"/>
      <param name="max_intron_length" value="500000"/>
      <param name="max_multihits" value="40"/>
      <param name="min_segment_intron" value="50" />
      <param name="max_segment_intron" value="500000" />
      <param name="seg_mismatches" value="2"/>
      <param name="seg_length" value="25"/>
      <conditional name="indel_search">
        <param name="allow_indel_search" value="No"/>
      </conditional>
      <conditional name="own_junctions">
        <param name="use_junctions" value="Yes" />
        <conditional name="gene_model_ann">
          <param name="use_annotations" value="No" />
        </conditional>
        <conditional name="raw_juncs">
          <param name="use_juncs" value="No" />
        </conditional>
        <conditional name="no_novel_juncs">
          <param name="no_novel_juncs" value="No" />
        </conditional>
      </conditional>
      <conditional name="coverage_search">
        <param name="use_search" value="No" />
      </conditional>
      <param name="microexon_search" value="Yes" />
      <conditional name="bowtie2_settings">
        <param name="b2_settings" value="No" />
      </conditional>
      <!-- Fusion search params -->
      <conditional name="fusion_search">
        <param name="do_search" value="Yes" />
        <param name="anchor_len" value="21" />
        <param name="min_dist" value="10000021" />
        <param name="read_mismatches" value="3" />
        <param name="multireads" value="4" />
        <param name="multipairs" value="5" />
        <param name="ignore_chromosomes" value="chrM"/>
      </conditional>
    </conditional>
    <conditional name="readGroup">
      <param name="specReadGroup" value="no" />
    </conditional>
    <output name="junctions" file="tophat2_out4j.bed" />
    <output name="accepted_hits" file="tophat_out4h.bam" compare="sim_size" />
</test>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must match the name of the
associated input ``conditional``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestRepeat">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

Specify test parameters below an iteration of a ``repeat`` block with this
element.

``param`` elements in a ``test`` block can be arranged into nested ``repeat``,
``conditional``, and ``select`` structures to match the inputs. While this might
be overkill for simple tests, it helps prevent ambiguous definitions and keeps
things organized in large test cases. A future ``profile`` version of Galaxy
tools may require ``repeat`` blocks be explicitly defined with this directive.

### Examples

The test tool [disambiguate_repeats.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/disambiguate_repeats.xml)
demonstrates the use of this directive.

This first test case demonstrates that this block allows different values for
the ``param`` named ``input`` to be tested even though this parameter name
appears in two different ``<repeat>`` elements in the ``<inputs>`` definition.

```xml
<!-- Can disambiguate repeats and specify multiple blocks using,
     nested structure. -->
<test>
    <repeat name="queries">
        <param name="input" value="simple_line.txt"/>
    </repeat>
    <repeat name="more_queries">
        <param name="input" value="simple_line_alternative.txt"/>
    </repeat>
    <output name="out_file1">
        <assert_contents>
            <has_line line="This is a line of text." />
            <has_line line="This is a different line of text." />
        </assert_contents>
    </output>
</test>
```

The second definition in that file demonstrates repeated ``<repeat>`` blocks
allowing multiple instances of a single repeat to be specified.

```xml
<!-- Multiple such blocks can be specified but only with newer API
     driven tests. -->
<test>
    <repeat name="queries">
        <param name="input" value="simple_line.txt"/>
    </repeat>
    <repeat name="queries">
        <param name="input" value="simple_line_alternative.txt"/>
    </repeat>
    <repeat name="more_queries">
        <param name="input" value="simple_line.txt"/>
    </repeat>
    <repeat name="more_queries">
        <param name="input" value="simple_line_alternative.txt"/>
    </repeat>
    <output name="out_file1" file="simple_lines_interleaved.txt"/>
</test>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestParamElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must match the name of the
associated input ``repeat``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestParam">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set defines the tool's input parameters for executing the tool via the
functional test framework. See [test](#tool-tests-test) documentation for
some simple examples of parameters.

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="collection" type="TestCollection" minOccurs="0" maxOccurs="1" />
      <xs:element name="composite_data" type="TestCompositeData" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="metadata" type="TestParamMetadata" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must match the name of the
associated input parameter (``param``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must be one of the legal
values that can be assigned to an input parameter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftype" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This attribute name should be included
only with parameters of ``type`` ``data`` for the tool. If this
attribute name is not included, the functional test framework will attempt to
determine the data type for the input dataset using the data type sniffers.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dbkey" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Specifies a ``dbkey`` value for the
referenced input dataset. This is only valid if the corresponding parameter is
of ``type`` ``data``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestCompositeData">
    <xs:annotation>
      <xs:documentation xml:lang="en">Define extra composite input files for test input.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Path relative to test-data of composite file.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftype" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Optional datatype of composite file for test input.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestCollection">
    <xs:annotation>
      <xs:documentation xml:lang="en">Definition of a collection for test input.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="element" type="TestParam" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Type of collection to create.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestOutput">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set defines the variable that names the output dataset for the
functional test framework. The functional test framework will execute the tool
using the parameters defined in the ``<param>`` tag sets and generate a
temporary file, which will either be compared with the file named in the
``file`` attribute value or checked against assertions made by a child
``assert_contents`` tag to verify that the tool is functionally correct.

        ]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestOutputElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <!-- TODO: This would be more percise if this was required if at the top-level. -->
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

This value is the same as the value of the ``name`` attribute of the ``<data>``
tag set contained within the tool's ``<outputs>`` tag set.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="file" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

If specified, this value is the name of the output file stored in the target
``test-data`` directory which will be used to compare the results of executing
the tool via the functional test framework.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftype" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

If specified, this value will be checked against the corresponding output's
data type. If these do not match, the test will fail.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sort" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">This flag causes the lines of the output
to be sorted before they are compared to the expected output. This could be
useful for non-deterministic output.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">An alias for ``file``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="md5" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

If specified, the target output's MD5 hash should match the value specified
here. For large static files it may be inconvenient to upload the entiry file
and this can be used instead.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checksum" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

If specified, the target output's checksum should match the value specified
here. This value should have the form ``hash_type:hash_value``
(e.g. ``sha1:8156d7ca0f46ed7abac98f82e36cfaddb2aca041``). For large static files
it may be inconvenient to upload the entiry file and this can be used instead.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compare" type="TestOutputCompareType">
    </xs:attribute>
    <xs:attribute name="lines_diff" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``compare`` is set to ``diff``, the number of lines of difference to allow (each line with a modification is a line added and a line removed so this counts as two lines).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delta" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``compare`` is set to ``sim_size``, this is the number of bytes different allowed.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="TestOutputElement">
    <xs:choice>
      <xs:element name="element" type="TestOutput"/>
      <!-- TODO: This would be more percise if this was only allowed at the top-level. -->
      <xs:element name="discovered_dataset" type="TestDiscoveredDataset"/>
      <!-- TODO: To be more percise only one assert_contents is allowed - this should not be in here. -->
      <xs:element name="assert_contents" type="TestAssertions">
        <xs:annotation>
          <xs:documentation><![CDATA[
$assertions

### Examples

The following demonstrtes a wide variety of text-based and tabular
assertion statements.

```xml
<output name="out_file1">
    <assert_contents>
        <has_text text="chr7" />
        <not_has_text text="chr8" />
        <has_text_matching expression="1274\d+53" />
        <has_line_matching expression=".*\s+127489808\s+127494553" />
        <!-- &#009; is XML escape code for tab -->
        <has_line line="chr7&#009;127471195&#009;127489808" />
        <has_n_columns n="3" />
    </assert_contents>
</output>
```

The following demonstrtes a wide variety of XML assertion statements.

```xml
<output name="out_file1">
    <assert_contents>
        <is_valid_xml />
        <has_element_with_path path="BlastOutput_param/Parameters/Parameters_matrix" />
        <has_n_elements_with_path n="9" path="BlastOutput_iterations/Iteration/Iteration_hits/Hit/Hit_num" />
        <element_text_matches path="BlastOutput_version" expression="BLASTP\s+2\.2.*" />
        <element_text_is path="BlastOutput_program" text="blastp" />
        <element_text path="BlastOutput_iterations/Iteration/Iteration_hits/Hit/Hit_def">
            <not_has_text text="EDK72998.1" />
            <has_text_matching expression="ABK[\d\.]+" />
        </element_text>
    </assert_contents>
</output>
```

The following demonstrtes verifying XML content with XPath-like expressions.

```xml
<output name="out_file1">
    <assert_contents>
        <attribute_is path="outerElement/innerElement1" attribute="foo" text="bar" />
        <attribute_matches path="outerElement/innerElement2" attribute="foo2" expression="bar\d+" />
    </assert_contents>
</output>
```

]]></xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- TODO: This would be more percise if this was only allowed at the top-level. -->
      <xs:element name="extra_files" type="TestExtraFile" />
      <xs:element name="metadata" type="TestOutputMetadata"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="TestParamMetadata">
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestOutputMetadata">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This directive specifies a test for an output's metadata as an expected key-value pair.

### Example

The functional test tool
[tool_provided_metadata_1.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/tool_provided_metadata_1.xml)
provides a demonstration of using this tag.

```xml
<test>
  <param name="input1" value="simple_line.txt" />
  <output name="out1" file="simple_line.txt" ftype="txt">
    <metadata name="name" value="my dynamic name" />
    <metadata name="info" value="my dynamic info" />
    <metadata name="dbkey" value="cust1" />
  </output>
</test>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name of the metdata element to check.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Expected value (as a string) of metadata value.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TestDiscoveredDataset">
    <xs:annotation>
      <xs:documentation><![CDATA[

This directive specifies a test for an output's discovered dataset. It acts as an
``output`` test tag in many ways and can define any tests of that tag (e.g.
``assert_contents``, ``value``, ``compare``, ``md5``, ``checksum``, ``metadata``, etc...).

### Example

The functional test tool
[multi_output_assign_primary.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/multi_output_assign_primary.xml)
provides a demonstration of using this tag.

```xml
<test>
  <param name="num_param" value="7" />
  <param name="input" ftype="txt" value="simple_line.txt"/>
  <output name="sample">
    <assert_contents>
      <has_line line="1" />
    </assert_contents>
    <!-- no sample1 it was consumed by named output "sample" -->
    <discovered_dataset designation="sample2" ftype="tabular">
      <assert_contents><has_line line="2" /></assert_contents>
    </discovered_dataset>
    <discovered_dataset designation="sample3" ftype="tabular">
      <assert_contents><has_line line="3" /></assert_contents>
    </discovered_dataset>
  </output>
</test>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="TestOutput">
        <xs:attribute type="xs:string" name="designation">
          <xs:annotation>
            <xs:documentation xml:lang="en">The designation of the discovered dataset.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TestExtraFile">
    <xs:annotation>
      <xs:documentation xml:lang="en">Define test for extra files on corresponding output.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="TestOutput">
        <xs:attribute type="xs:string" name="type">
          <xs:annotation>
            <xs:documentation xml:lang="en">Extra file type (either ``file`` or ``directory``).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TestOutputCollection">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

Define tests for extra files corresponding to an output collection.

``output_collection`` directives should specify a ``name`` and ``type``
attribute to describe the expected output collection as a whole.

Expectations about collecton contents are described using child ``element``
directives. For nested collections, these child ``element`` directives may
themselves contain children.

### Examples

The [genetrack](https://github.com/galaxyproject/tools-iuc/blob/master/tools/genetrack/genetrack.xml)
tool demonstrates basic usage of an ``output_collection`` test expectation.

```xml
<test>
    <param name="input" value="genetrack_input2.gff" ftype="gff" />
    <param name="input_format" value="gff" />
    <param name="sigma" value="5" />
    <param name="exclusion" value="20" />
    <param name="up_width" value="10" />
    <param name="down_width" value="10" />
    <param name="filter" value="3" />
    <output_collection name="genetrack_output" type="list">
        <element name="s5e20u10d10F3_on_data_1" file="genetrack_output2.gff" ftype="gff" />
    </output_collection>
</test>
```

The [CWPair2](https://github.com/galaxyproject/tools-iuc/blob/master/tools/cwpair2/cwpair2.xml)
tool demonstrates that ``element``s can specify a ``compare`` attribute just
like [output](#tool-tests-test-output).

```xml
<test>
    <param name="input" value="cwpair2_input1.gff" />
    <param name="up_distance" value="25" />
    <param name="down_distance" value="100" />
    <param name="method" value="all" />
    <param name="binsize" value="1" />
    <param name="threshold_format" value="relative_threshold" />
    <param name="relative_threshold" value="0.0" />
    <param name="output_files" value="matched_pair" />
    <output name="statistics_output" file="statistics1.tabular" ftype="tabular" />
    <output_collection name="MP" type="list">
        <element name="data_MP_closest_f0u25d100_on_data_1.gff" file="closest_mp_output1.gff" ftype="gff" compare="contains"/>
        <element name="data_MP_largest_f0u25d100_on_data_1.gff" file="largest_mp_output1.gff" ftype="gff" compare="contains"/>
        <element name="data_MP_mode_f0u25d100_on_data_1.gff" file="mode_mp_output1.gff" ftype="gff" compare="contains"/>
    </output_collection>
</test>
```

The
[collection_creates_dynamic_nested](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/collection_creates_dynamic_nested.xml)
test tool demonstrates the use of nested ``element`` directives as described
above. Notice also that it tests the output with ``assert_contents`` instead of
supplying a ``file`` attribute. Like hinted at with with ``compare`` attribute
above, the ``element`` tag can specify any of the test attributes that apply to
the [output](#tool-tests-test-output) (e.g. ``md5``, ``compare``, ``diff``,
etc...).

```xml
<test>
  <param name="foo" value="bar" />
  <output_collection name="list_output" type="list:list">
    <element name="oe1">
      <element name="ie1">
        <assert_contents>
          <has_text_matching expression="^A\n$" />
        </assert_contents>
      </element>
      <element name="ie2">
        <assert_contents>
          <has_text_matching expression="^B\n$" />
        </assert_contents>
      </element>
    </element>
    <element name="oe2">
      <element name="ie1">
        <assert_contents>
          <has_text_matching expression="^C\n$" />
        </assert_contents>
      </element>
      <element name="ie2">
        <assert_contents>
          <has_text_matching expression="^D\n$" />
        </assert_contents>
      </element>
    </element>
    <element name="oe3">
      <element name="ie1">
        <assert_contents>
          <has_text_matching expression="^E\n$" />
        </assert_contents>
      </element>
      <element name="ie2">
        <assert_contents>
          <has_text_matching expression="^F\n$" />
        </assert_contents>
      </element>
    </element>
  </output_collection>
</test>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="element" type="TestOutput" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

This value is the same as the value of the ``name`` attribute of the
``<collecton>`` tag set contained within the tool's ``<outputs>`` tag set.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Expected collection type (e.g. ``list``, ``paired``,
or ``list:paired``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="count" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Number of elements in output collection.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="TestAssertions">
    <xs:annotation>
      <xs:documentation><![CDATA[
This tag set defines a sequence of checks or assertions to run against the
target output. This tag requires no attributes, but child tags should be used to
define the assertions to make about the output. The functional test framework
makes it easy to extend Galaxy with such tags, the following table summarizes
many of the default assertion tags that come with Galaxy and examples of each
can be found below.

The implementation of these tags are simply Python functions defined in the
[galaxy.tools.verify.asserts](https://github.com/galaxyproject/galaxy/tree/dev/lib/galaxy/tools/verify/asserts)
module.
]]>
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TestAssertion" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="TestAssertion">
    <xs:choice>
      <xs:element name="has_text" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the specified ``text`` appears in the output (e.g. ``<has_text text="chr7">``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="not_has_text" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the specified ``text`` does not appear in the output (e.g. ``<not_has_text text="chr8" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_text_matching" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts text matching the specified regular expression (``expression``) appears in the output (e.g. ``<has_text_matching expression="1274\d+53" />`` ).]]>
        </xs:documentation>
      </xs:annotation>
      </xs:element>
      <xs:element name="has_line" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts a line matching the specified string (``line``) appears in the output (e.g. ``<has_line line="A full example line." />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_line_matching" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts a line matching the specified regular expression (``expression``) appears in the output (e.g. ``<has_line_matching expression=".*\s+127489808\s+127494553" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_n_columns" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts tabular output contains the specified number (``n``) of columns (e.g. ``<has_n_columns n="3" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="is_valid_xml" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the output is a valid XML file (e.g. ``<is_valid_xml />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_element_with_path" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML output contains at least one element (or tag) with the specified XPath-like ``path`` (e.g. ``<has_element_with_path path="BlastOutput_param/Parameters/Parameters_matrix" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="has_n_elements_with_path" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML output contains the specified number (``n``) of elements (or tags) with the specified XPath-like ``path`` (e.g. ``<has_n_elements_with_path n="9" path="BlastOutput_iterations/Iteration/Iteration_hits/Hit/Hit_num" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="element_text_is" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the text of the XML element with the specified XPath-like ``path`` is the specified ``text`` (e.g. ``<element_text_is path="BlastOutput_program" text="blastp" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="element_text_matches">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the text of the XML element with the specified XPath-like ``path`` matches the regular expression defined by ``expression`` (e.g. ``<element_text_matches path="BlastOutput_version" expression="BLASTP\s+2\.2.*" />``).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="attribute_is" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML ``attribute`` for the element (or tag) with the specified XPath-like ``path`` is the specified ``text`` (e.g. ``<attribute_is path="outerElement/innerElement1" attribute="foo" text="bar" />`` ).]]>
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="attribute_matches" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[Asserts the XML ``attribute`` for the element (or tag) with the specified XPath-like ``path`` matches the regular expression specified by ``expression`` (e.g. ``<attribute_matches path="outerElement/innerElement2" attribute="foo2" expression="bar\d+" />``).]]></xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="element_text" type="xs:anyType">
        <xs:annotation>
          <xs:documentation><![CDATA[This tag allows the developer to recurisively specify additional assertions as child elements about just the text contained in the element specified by the XPath-like ``path`` (e.g. ``<element_text path="BlastOutput_iterations/Iteration/Iteration_hits/Hit/Hit_def"><not_has_text text="EDK72998.1" /></element_text>``).]]></xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Inputs">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Consists of all tag sets that define the
tool's input parameters. Each ``<param>`` tag within the ``<inputs>`` tag set
maps to a command line parameter within the [command](#tool-command) tag. Most
tools will not need to specify any attributes on this tag itself.]]>
</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">URL used by data source tools.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="check_values" type="PermissiveBoolean" default="true">
      <xs:annotation>
        <xs:documentation xml:lang="en">Set to ``false`` to disable parameter checking in data source tools.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="method" type="URLmethodType">
      <xs:annotation>
        <xs:documentation xml:lang="en">Data source HTTP action (e.g. ``get`` or ``put``) to use.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="target" type="TargetType">
      <xs:annotation>
        <xs:documentation xml:lang="en">UI link target to use for data source tools (e.g. ``_top``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="nginx_upload" type="PermissiveBoolean" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en">This boolean indicates if this is an upload tool or not.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:group name="InputElement">
    <xs:choice>
      <xs:element name="param" type="Param"/>
      <xs:element name="repeat" type="Repeat"/>
      <xs:element name="conditional" type="Conditional"/>
      <xs:element name="section" type="Section"/>
      <xs:element name="upload_dataset" type="xs:anyType">
        <xs:annotation>
          <xs:documentation xml:lang="en">Internal, intentionally undocumented feature.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="display" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for display</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="InputType" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for InputType</xs:documentation>
    </xs:annotation>
    <xs:sequence/>
  </xs:complexType>


  <xs:complexType name="Conditional">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This is a container for conditional parameters in the tool (must contain 'when'
tag sets) - the command line (or portions thereof) are then wrapped in an if-else
statement. A good example tool that demonstrates many conditional parameters is
[biom_convert.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tools/biom_format/biom_convert.xml).

```xml
<conditional name="input_type">
    <param name="input_type_selector" type="select" label="Choose the source BIOM format">
        <option value="tsv" selected="True">Tabular File</option>
        <option value="biom">BIOM File</option>
    </param>
    <when value="tsv">
        <param name="input_table" type="data" format="tabular" label="Tabular File" argument="--input-fp"/>
        <param name="process_obs_metadata" type="select" label="Process metadata associated with observations when converting" argument="--process-obs-metadata">
            <option value="" selected="True">Do Not process metadata</option>
            <option value="taxonomy">taxonomy</option>
            <option value="naive">naive</option>
            <option value="sc_separated">sc_separated</option>
        </param>
    </when>
    <when value="biom">
        <param name="input_table" type="data" format="biom1" label="Tabular File" argument="--input-fp"/>
    </when>
</conditional>
```

The first directive following the conditional is a [param](#tool-inputs-param),
this param must be of type ``select`` or ``boolean``. Depending on the value a
user selects for this "test" parameter - different UI elements will be shown.
These different paths are described by the following the ``when`` blocks shown
above.

The following Cheetah block demonstrates the use of the ``conditional``
shown above:

```
biom convert -i "${input_type.input_table}" -o "${output_table}"
#if str( $input_type.input_type_selector ) == "tsv":
    #if $input_type.process_obs_metadata:
        --process-obs-metadata "${input_type.process_obs_metadata}"
    #end if
#end if
```

Notice that the parameter ``input_table`` appears down both ``when`` clauses
so ``${input_type.input_table}`` appears unconditionally but we need to
conditionally reference ``${input_type.process_obs_metadata}`` with a Cheetah
``if`` statement.

A common use of the conditional wrapper is to select between reference data
managed by the Galaxy admins (for instance via
[data managers](https://wiki.galaxyproject.org/Admin/Tools/DataManagers)
) and
history files. A good example tool that demonstrates this is
the [Bowtie 2](https://github.com/galaxyproject/tools-devteam/blob/master/tools/bowtie2/bowtie2_wrapper.xml) wrapper.

```xml
<conditional name="reference_genome">
  <param name="source" type="select" label="Will you select a reference genome from your history or use a built-in index?" help="Built-ins were indexed using default options. See `Indexes` section of help below">
    <option value="indexed">Use a built-in genome index</option>
    <option value="history">Use a genome from the history and build index</option>
  </param>
  <when value="indexed">
    <param name="index" type="select" label="Select reference genome" help="If your genome of interest is not listed, contact the Galaxy team">
      <options from_data_table="bowtie2_indexes">
        <filter type="sort_by" column="2"/>
        <validator type="no_options" message="No indexes are available for the selected input dataset"/>
      </options>
    </param>
  </when>
  <when value="history">
    <param name="own_file" type="data" format="fasta" label="Select reference genome" />
  </when>
</conditional>
```

The Bowtie 2 wrapper also demonstrates other conditional paths - such as choosing
between paired inputs of single stranded inputs.
]]></xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="InputType">
        <xs:sequence>
          <xs:group ref="InputElement" minOccurs="0" maxOccurs="1" />
          <xs:element name="when" type="ConditionalWhen" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name for this element</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value_from" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[Infrequently used option to dynamically access Galaxy internals, this should be avoided.

Galaxy method to execute.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value_ref" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[Infrequently used option to dynamically access Galaxy internals, this should be avoided.

Referenced parameter to pass method.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value_ref_in_group" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation><![CDATA[Infrequently used option to dynamically access Galaxy internals, this should be avoided.

Is referenced parameter is the same group.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="label" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Human readable description for the conditional, unused in the Galaxy UI currently.</xs:documentation>
          </xs:annotation>
        </xs:attribute>

      </xs:extension>
    </xs:complexContent>
  </xs:complexType>



  <xs:complexType name="ConditionalWhen">
    <xs:annotation>
      <xs:documentation xml:lang="en">This directive describes one potential
set of input for the tool at this depth. See documentation for the
[conditional](#tool-inputs-conditional) block for more details and examples (XML
and corresponding Cheetah conditionals).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Value for the tool form test parameter
corresponding to this ``when`` block.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>



  <xs:complexType name="Repeat">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
See
[xy_plot.xml](https://github.com/galaxyproject/tools-devteam/blob/master/tools/xy_plot/xy_plot.xml)
for an example of how to use this tag set. This is a container for any tag sets
that can be contained within the ``<inputs>`` tag set. When this is used, the
tool will allow the user to add any number of additional sets of the contained
parameters (an option to add new iterations will be displayed on the tool form).
All input parameters contained within the ``<repeat>`` tag can be retrieved by
enumerating over ``$<name_of_repeat_tag_set>`` in the relevant Cheetah code.
This returns the rank and the parameter objects of the repeat container. See the
Cheetah code below.

### Example

This part is contained in the ``<inputs>`` tag set.

```xml
<repeat name="series" title="Series">
    <param name="input" type="data" format="tabular" label="Dataset"/>
    <param name="xcol" type="data_column" data_ref="input" label="Column for x axis"/>
    <param name="ycol" type="data_column" data_ref="input" label="Column for y axis"/>
</repeat>
```

This Cheetah code can be used in the ``<command>`` tag set or the
``<configfile>`` tag set.

```xml
#for $i, $s in enumerate( $series )
    rank_of_series=$i
    input_path='${s.input}'
    x_colom=${s.xcol}
    y_colom=${s.ycol}
#end for
```

### Testing

This is an example test case with multiple repeat elements for the example above.

```xml
<test>
    <repeat name="series">
        <param name="input" value="tabular1.tsv" ftype="tabular"/>
        <param name="xcol" value="1"/>
        <param name="ycol" value="2"/>
    </repeat>
    <repeat name="series">
        <param name="input" value="tabular2.tsv" ftype="tabular"/>
        <param name="xcol" value="4"/>
        <param name="ycol" value="2"/>
    </repeat>
    <output name="out_file1" file="cool.pdf" ftype="pdf" />
</test>
```

See the documentation on the [repeat test directive](#tool-tests-test-repeat).

An older way to specify repeats in a test is by instances that are created by referring to names with a special format: "<repeat name>_<repeat index>|<param name>"

```xml
<test>
    <param name="series_0|input" value="tabular1.tsv" ftype="tabular"/>
    <param name="series_0|xcol" value="1"/>
    <param name="series_0|ycol" value="2"/>
    <param name="series_1|input" value="tabular2.tsv" ftype="tabular"/>
    <param name="series_1|xcol" value="4"/>
    <param name="series_1|ycol" value="2"/>
    <output name="out_file1" file="cool.pdf" ftype="pdf" />
</test>
```

The test tool [disambiguate_repeats.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/disambiguate_repeats.xml)
demonstrates both testing strategies.

]]></xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="InputType">
        <xs:sequence>
          <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name for this element</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="title" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The title of the repeat section, which will be displayed on the tool form. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min" type="xs:integer">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The minimum number of repeat units. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max" type="xs:integer">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The maximum number of repeat units. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="default" type="xs:integer" default="1">
          <xs:annotation>
            <xs:documentation xml:lang="en"> The default number of repeat units. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="help" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Short help description for repeat element.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Section">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
This tag is used to group parameters into sections of the interface. Sections
are implemented to replace the commonly used tactic of hiding advanced options
behind a conditional, with sections you can easily visually group a related set
of options.

### Example

The XML configuration is relatively trivial for sections:

```xml
<inputs>
    <section name="adv" title="Advanced Options" expanded="False">
        <param name="plot_color" type="color" label="Track color" />
    </section>
</inputs>
```

In your command template, you'll need to include the section name to access the
variable:

```
--color $adv.plot_color
```

Further examples can be found in the [test case](https://github.com/galaxyproject/galaxy/blob/master/test/functional/tools/section.xml) from [PR #35](https://github.com/galaxyproject/galaxy/pull/35)
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">The internal key used for the section.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="title" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Human readable label for the section.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expanded" type="PermissiveBoolean" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en">Whether the section should be expanded by default or not. If not, the default set values are used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="help" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Short help description for section, rendered just below the section.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Param">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

Contained within the ``<inputs>`` tag set - each of these specifies a field that
will be displayed on the tool form. Ultimately, the values of these form fields
will be passed as the command line parameters to the tool's executable.

### Common Attributes

The attributes valid for this tag vary wildly based on the ``type`` of the
parameter being described. All the attributes for the ``param`` element are
documented below for completeness, but here are the common ones for each
type are as follows:

$attribute_list:name,type,optional,label,help,argument:4

### Parameter Types

#### ``text``

When ``type="text"``, the parameter is free form text and appears as a text box
in the tool form.

##### Examples

Sometimes you need labels for data or graph axes, chart titles, etc. This can be
done using a text field. The following will create a text box 30 characters wide
with the default value of "V1".

```xml
<param name="xlab" size="30" type="text" value="V1" label="Label for x axis"/>
```

The ``size`` parameter can be two dimensional, if it is the textbox will be
rendered on the tool form as a text area instead of a single line text box.

```xml
<param name="foo" type="text" area="True" size="5x25" />
```

$attribute_list:value,size,area:5

#### ``integer`` and ``float``

These parameters represent whole number and real numbers, respectively.

##### Example

```
<param name="region_size" size="4" type="integer" value="1" label="flanking regions of size" />
```

$attribute_list:value,min,max:5

#### ``boolean``

This represents a binary true or false value.

$attribute_list:checked,truevalue,falsevalue:5

#### ``data``

A dataset from the current history. Multiple types might be used for the param form.

##### Examples

The following will find all "coordinate interval files" contained within the
current history and dynamically populate a select list with them. If they are
selected, their destination and internal file name will be passed to the
appropriate command line variable.

```xml
<param name="interval_file" type="data" format="interval" label="near intervals in"/>
```

The following demonstrates a ``param`` which may accept multiple files and
multiple formats.

```xml
<param format="sam,bam" multiple="true" name="bamOrSamFile" type="data"
       label="Alignments in BAM or SAM format"
       help="The set of aligned reads." />
```

Perhaps counter-intuitively, a ``multiple="true"`` data parameter requires at least one
data input. If ``optional="true"`` is specified, this condition is relaxed and the user
is allowed to select 0 datasets. Unfortunately, if 0 datasets are selected the resulting
value for the parameter during Cheetah templating (such as in a ``command`` block) will
effectively be a list with one ``None``-like entity in it.

The following idiom can be used to iterate over such a list and build a hypothetical ``-B``
parameter for each file - the ``if`` block is used to handle the case where a ``None``-like
entity appears in the list because no files were selected: 

```
#for $input in $input1
    #if $input
        -B "$input"
    #end if
#end for
```

Some example tools using ``multiple="true"`` data parameters include:

- [multi_data_param.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/multi_data_param.xml)
- [multi_data_optional.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/multi_data_optional.xml)

Additionally, a detailed discussion of handling multiple homogenous files can be found in the
the [Planemo Documentation](https://planemo.readthedocs.io/en/latest/writing_advanced.html#consuming-collections)
on this topic.

$attribute_list:format,multiple:5

#### ``select``

The following will create a select list containing the options "Downstream" and
"Upstream". Depending on the selection, a ``d`` or ``u`` value will be passed to
the ``$upstream_or_down`` variable on the command line.

```xml
<param name="upstream_or_down" type="select" label="Get">
  <option value="u">Upstream</option>
  <option value="d">Downstream</option>
</param>
```

The following will create a checkbox list allowing the user to select
"Downstream", "Upstream", both, or neither. Depending on the selection, the
value of ``$upstream_or_down`` will be ``d``, ``u``, ``u,d``, or "".

```xml
<param name="upstream_or_down" type="select" label="Get" multiple="true" display="checkboxes">
  <option value="u">Upstream</option>
  <option value="d">Downstream</option>
</param>
```

$attribute_list:data_ref,dynamic_options,display,multiple:5

#### ``data_column``

This parameter type is used to select columns from a parameter.

$attribute_list:force_select,numerical,use_header_name:5

#### ``drill_down``

$attribute_list:hierarchy:5

#### ``data_collection``

The following will create a parameter that only accepts paired FASTQ files grouped into a collection.

##### Examples

```xml
<param name="inputs" type="data_collection" collection_type="paired" label="Input FASTQs" format="fastq">
</param>
```

More detailed information on writing tools that consume collections can be found
in the [planemo documentation](https://planemo.readthedocs.io/en/latest/writing_advanced.html#collections).

$attribute_list:format,collection_type:5

#### ``color``

##### Examples

The following example will create a color selector parameter.

```xml
<param name="feature_color" type="color" label="Default feature color" value="#ff00ff">
</param>
```

Given that the output includes a pound sign, it is often convenient to use a
sanitizer to prevent Galaxy from escaping the result.

```xml
<param name="feature_color" type="color" label="Default feature color" value="#ff00ff">
  <sanitizer>
    <valid initial="string.letters,string.digits">
      <add value="#" />
    </valid>
  </sanitizer>
</param>
```

$attribute_list:value,rgb:5

This covers examples of the most common parameter types, the remaining parameter
types are more obsecure and less likely to be useful for most tool authors.

]]></xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="InputType">
        <xs:sequence>
          <xs:group ref="ParamElement" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="type" type="ParamType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[

Describes the parameter type - each different type as different semantics and
the tool form widget is different. Currently valid parameter types are:
``text``,  ``integer``,  ``float``,  ``boolean``,  ``genomebuild``,  ``select``,
``color``,  ``data_column``,  ``hidden``,  ``hidden_data``,  ``baseurl``,
``file``,  ``ftpfile``,  ``data``,  ``data_collection``,  ``library_data``,
``drill_down``. The definition of supported parameter types as defined in the
``parameter_types`` dictionary in
[/lib/galaxy/tools/parameters/basic.py](https://github.com/galaxyproject/galaxy/blob/master/lib/galaxy/tools/parameters/basic.py).

]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="xs:string">
            <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[Name for this element. This ``name``
is used as the Cheetah variable containing the user-supplied parameter name in
``command`` and ``configfile`` elements. The name should not contain pipes or
periods (e.g. ``.``). Some "reserved" names are ``REDIRECT_URL``,
``DATA_URL``, ``GALAXY_URL``.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <!-- TODO: add unique constraints... -->
        <xs:attribute name="area" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Boolean indicating if this should be
rendered as a one line text box (if ``false``) or a multi-line text area (if
``true``).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="argument" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[

If the parameter reflects just one command line argument of a certain tool, this
tag should be set to that particular argument. It is rendered in parenthesis
after the help section, and it will create the name attribute from the argument
attribute by stripping the dashes (e.g. if ``argument="--sensitive"`` then
``name="sensitive"`` is implicit).

]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="label" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The attribute value will be
displayed on the tool page as the label of the form field
(``label="Sort Query"``).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="help" type="xs:string">
          <xs:annotation gxdocs:best_practices="parameter-help">
            <xs:documentation xml:lang="en">Short bit of text, rendered on the
tool form just below the associated field to provide information about the
field.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The default value for this
parameter.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="default_value" type="xs:string" gxdocs:deprecated="true">
          <xs:annotation>
            <xs:documentation xml:lang="en">Deprecated way to specify default value for column parameters (use ``value`` instead).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="optional" type="xs:string" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">If ``false``, parameter must have a
value. Defaults to "false".</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rgb" type="xs:string" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">If ``false``, the returned value will be in Hex color code. If ``true``
it will be a RGB value e.g. 0,0,255. This attribute is only valid when ``type`` is ``color``.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min" type="xs:float">
          <xs:annotation>
            <xs:documentation xml:lang="en">Minimum valid parameter value - only
valid when ``type`` is ``integer`` or ``float``.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max" type="xs:float">
          <xs:annotation>
            <xs:documentation xml:lang="en">Maximum valid parameter value - only
valid when ``type`` is ``integer`` or ``float``.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="format" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Only if ``type`` attribute value is
``data`` or ``data_collection`` - the list of supported data formats is
contained in the
[/config/datatypes_conf.xml.sample](https://github.com/galaxyproject/galaxy/blob/dev/config/datatypes_conf.xml.sample)
file. Use the file extension.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="collection_type" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[

This is only valid if ``type`` is ``data_collection``. Restrict the kind of
collection that can be consumed by this parameter (e.g. ``paired``,
``list:paired``, ``list``). Multiple such collection types can be specified here
as a comma separated list.

              ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="data_ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[

Only valid if ``type`` attribute value is ``select`` or ``data_column``. Used
with select lists whose options are dynamically generated based on certain
metadata attributes of the dataset upon which this parameter depends (usually
but not always the tool's input dataset).

            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="accept_default" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="force_select" type="PermissiveBoolean" gxdocs:deprecated="true">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used only if the ``type`` attribute
value is ``data_column``, this is deprecated and the inverse of ``optional``.
Set to ``false`` to not force user to select an option in the list.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="use_header_names" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used only if the ``type`` attribute
value is ``data_column``, if ``true`` Galaxy assumes first row of ``data_ref``
is a header and builds the select list with these values rather than the more
generic ``c1`` ... ``cN``.
</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="display" type="DisplayType">
          <xs:annotation>
            <xs:documentation xml:lang="en">This attribute is used only if
``type`` attribute value is ``select`` - render a select list as a set of check
boxes or radio buttons. Defaults to a drop-down menu select list.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="multiple" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Allow multiple valus to be selected.
Valid with ``data`` and ``select`` parameters.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="numerical" type="PermissiveBoolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used only if the ``type`` attribute
value is ``data_column``, if ``true`` the column will be treated as numerical
when filtering columns based on metadata.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="hierarchy" type="HierarchyType">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used only if the ``type`` attribute
value is ``drill_down``, this attribute determines the drill down is
``recursive`` or ``exact``.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="checked" type="PermissiveBoolean" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">Set to ``true`` if the ``boolean``
parameter should be checked (or ``true``) by default.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="truevalue" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The parameter value in the Cheetah
template if the parameter is ``true`` or checked by the user. Only valid if
``type`` is ``boolean``.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="falsevalue" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The parameter value in the Cheetah
template if the parameter is ``false`` or not checked by the user. Only valid if
``type`` is ``boolean``.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="size" type="xs:string">
          <!-- TODO: can be integer or integerxinteger -->
          <xs:annotation>
            <xs:documentation xml:lang="en">Used only if ``type`` attribute
value is ``text``. To create a multi-line text box add an ``area="True"``
attribute to the param tag. This can be one dimensional (e.g. ``size="40"``)
or two dimensional (e.g. ``size="5x25"``).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <!-- metadata_name appears in some wrappers but I think this is a copy
             and paste problem and doesn't reflect something actually used by
             Galaxy.
        -->
        <!--
        <xs:attribute name="metadata_name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Documentation for metadata_name</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        -->
        <xs:attribute name="dynamic_options" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Deprecated/discouraged method to
allow access to Python code to generate options for a select list. See
``code``'s documentation for an example.
</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:group name="ParamElement">
    <xs:choice>
      <xs:element name="label" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for label</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="conversion" type="ParamConversion" />
      <xs:element name="option" type="ParamOption" />
      <xs:element name="options" type="ParamOptions"/>
      <xs:element name="validator" type="Validator" />
      <xs:element name="sanitizer" type="Sanitizer"/>
      <xs:element name="help" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for help</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>

  <xs:simpleType name="ParamType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ParamType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="text"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="float"/>
      <xs:enumeration value="color"/>
      <xs:enumeration value="boolean"/>
      <xs:enumeration value="genomebuild"/>
      <xs:enumeration value="library_data"/>
      <xs:enumeration value="select"/>
      <xs:enumeration value="data_column"/>
      <xs:enumeration value="hidden"/>
      <xs:enumeration value="hidden_data"/>
      <xs:enumeration value="baseurl"/>
      <xs:enumeration value="file"/>
      <xs:enumeration value="data"/>
      <xs:enumeration value="drill_down"/>
      <xs:enumeration value="data_collection"/>
    </xs:restriction>
  </xs:simpleType>


  <xs:complexType name="Command">
    <xs:annotation gxdocs:best_practices="command-tag">
      <xs:documentation xml:lang="en"><![CDATA[
This tag specifies how Galaxy should invoke the tool's executable, passing its
required input parameter values (the command line specification links the
parameters supplied in the form with the actual tool executable). Any word
inside it starting with a dollar sign (``$``) will be treated as a variable whose
values can be acquired from one of three sources: parameters, metadata, or
output files. After the substitution of variables with their values, the content
is interpreted with [Cheetah](https://pythonhosted.org/Cheetah/) and finally given
to the interpreter specified in the corresponding attribute (if any).

### Examples

The following uses a compiled executable ([bedtools](https://bedtools.readthedocs.io/en/latest/)).

```xml
<command>bed12ToBed6 -i '$input' > '$output'</command>
```

A few things to note about even this simple example:

* Input and output variables (boringly named ``input`` and ``output``)
  are expanded into paths using the ``$`` Cheetah directive.
* Paths should be quoted so that the Galaxy database files may contain spaces.
* We are building up a shell script - so special characters like ``>`` can be used
  (in this case the standard output of the bedtools call is written to the path
  specified by ``'$output'``).

The bed12ToBed6 tool can be found [here](https://github.com/galaxyproject/tools-iuc/blob/master/tools/bedtools/bed12ToBed6.xml).

A more sophisticated bedtools example demonstrates the use of loops, conditionals,
and uses whitespace to make a complex command very readable can be found in
[annotateBed](https://github.com/galaxyproject/tools-iuc/blob/master/tools/bedtools/annotateBed.xml)
tool.

```xml
<command><![CDATA[
bedtools annotate
        -i "${inputA}"
        #if $names.names_select == 'yes':
            -files
            #for $bed in $names.beds:
                '${bed.input}'
            #end for
            -names
            #for $bed in $names.beds:
                '${bed.inputName}'
            #end for
        #else:
            #set files = '" "'.join( [ str( $file ) for $file in $names.beds ] )
            -files '${files}'
            #set names = '" "'.join( [ str( $name.display_name ) for $name in $names.beds ] )
            -names '${names}'
        #end if
        $strand
        $counts
        $both
        > "${output}"
]]]]><![CDATA[></command>
```

The following example (taken from [xpath](https://github.com/galaxyproject/tools-iuc/blob/master/tools/xpath/xpath.xml) tool)
uses an interpreted executable. In this case a Perl script is shipped with the
tool and the directory of the tool itself is referenced with ``$__tool_directory__``.

```xml
<command>
  perl $__tool_directory__/xpath -q -e '$expression' '$input' > '$output'
</command>
```

The following example demonstrates accessing metadata from datasets. Metadata values
(e.g., ``${input.metadata.chromCol}``) are acquired from the ``Metadata`` model associated
with the objects selected as the values of each of the relative form field
parameters in the tool form. Accessing this information is generally enabled using
the following feature components.

A set of "metadata information" is defined for each supported data type (see the
``MetadataElement`` objects in the various data types classes in
[/lib/galaxy/datatypes](https://github.com/galaxyproject/galaxy/tree/dev/lib/galaxy/datatypes).
The ``DatasetFilenameWrapper`` class in the
[/lib/galaxy/tools/wrappers.py](https://github.com/galaxyproject/galaxy/blob/dev/lib/galaxy/tools/wrappers.py)
code file wraps a metadata collection to return metadata parameters wrapped
according to the Metadata spec.

```xml
<command><![CDATA[
        #set genome = $input.metadata.dbkey
        #set datatype = $input.datatype
        mkdir -p output_dir &&
        python $__tool_directory__/extract_genomic_dna.py
        --input '$input'
        --genome '$genome'
        #if $input.is_of_type("gff"):
            --input_format "gff"
            --columns "1,4,5,7"
            --interpret_features $interpret_features
        #else:
            --input_format "interval"
            --columns "${input.metadata.chromCol},${input.metadata.startCol},${input.metadata.endCol},${input.metadata.strandCol},${input.metadata.nameCol}"
        #end if
        --reference_genome_source $reference_genome_cond.reference_genome_source
        #if str($reference_genome_cond.reference_genome_source) == "cached"
            --reference_genome $reference_genome_cond.reference_genome.fields.path
        #else:
            --reference_genome $reference_genome_cond.reference_genome
        #end if
        --output_format $output_format_cond.output_format
        #if str($output_format_cond.output_format) == "fasta":
            --fasta_header_type $output_format_cond.fasta_header_type_cond.fasta_header_type
            #if str($output_format_cond.fasta_header_type_cond.fasta_header_type) == "char_delimited":
                --fasta_header_delimiter $output_format_cond.fasta_header_type_cond.fasta_header_delimiter
            #end if
        #end if
        --output '$output'
]]]]><![CDATA[></command>
```

In additon to demonstrating accessing metadata, this example demonstrates:

* ``$input.is_of_type("gff")`` which can be used to check if an input is of a
  given datatype.
* ``#set datatype = $input.datatype`` which is the syntax for defining variables
  in Cheetah.

### Reserved Variables

Galaxy provides a few pre-defined variables which can be used in your command line,
even though they don't appear in your tool's parameters.

Name | Description
---- | -----------
``$__tool_directory__`` | The directory the tool description (XML file) currently resides in (new in 15.03)
``$__new_file_path__`` | ``config/galaxy.ini``'s ``new_file_path`` value
``$__tool_data_path__`` | ``config/galaxy.ini``'s tool_data_path value
``$__root_dir__`` | Top-level Galaxy source directory made absolute via ``os.path.abspath()``
``$__datatypes_config__`` | ``config/galaxy.ini``'s datatypes_config value
``$__user_id__`` | Email's numeric ID (id column of ``galaxy_user`` table in the database)
``$__user_email__`` | User's email address
``$__app__`` | The ``galaxy.app.UniverseApplication`` instance, gives access to all other configuration file variables (e.g. $__app__.config.output_size_limit). Should be used as a last resort, may go away in future releases.

Additional runtime properties are available as environment variables. Since these
are not Cheetah variables (the values aren't available until runtime) these should likely
be escaped with a backslash (``\``) when appearing in ``command`` or ``configfile`` elements.

Name | Description
---- | -----------
``\${GALAXY_SLOTS:-4}`` | Number of cores/threads allocated by the job runner or resource manager to the tool for the given job (here 4 is the default number of threads to use if running via custom runner that does not configure GALAXY_SLOTS or in an older Galaxy runtime).

See the [Planemo docs](https://planemo.readthedocs.io/en/latest/writing_advanced.html#cluster-usage)
on the topic of ``GALAXY_SLOTS`` for more information and examples.

### Attributes

#### ``detect_errors``

If present on the ``command`` tag, this attribute can be one of:

* ``default`` no-op fallback to ``stdio`` tags and erroring on standard error output (for legacy tools).
* ``exit_code`` error if tool exit code is not 0. (The @jmchilton recommendation).
* ``aggressive`` error if tool exit code is not 0 or either ``Exception:`` or ``Error:``
  appears in standard error/output. (The @bgruening recommendation).

For newer tools with ``profile>=16.04``, the default behavior is ``exit_code``.
Legacy tools default to ``default`` behavior described above (erroring if the tool
produces any standard error output).

See [PR 117](https://github.com/galaxyproject/galaxy/pull/117) for more implementation
information and discussion on the ``detect_errors`` attribute.

#### ``strict``

This boolean forces the ``#set -e`` directive on in shell scripts - so that in a
multi-part command if any part fails the job exits with a non-zero exit code.
This is enabled by default for tools with ``profile>=16.04`` and disabled on
legacy tools.

#### ``interpreter``

Older tools may define an ``intepreter`` attribute on the command, but this is
deprecated and using the ``$__tool_directory__`` variable is superior.

]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="detect_errors" type="xs:string">
          <xs:annotation>
            <xs:documentation></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="interpreter" type="xs:string" gxdocs:deprecated="true">
          <xs:annotation>
            <xs:documentation xml:lang="en">This attribute defines the programming language in which the tool's executable file is written. Any language can be used (tools can be written in Python, C, Perl, Java, etc.). The executable file must be in the same directory of the XML file. If instead this attribute is not specified, the tag content should be a Bash command calling executable(s) available in the $PATH. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strict" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>


  <xs:complexType name="ParamOption">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

See [/tools/filters/sorter.xml](https://github.com/galaxyproject/galaxy/blob/master/tools/filters/sorter.xml)
for typical examples of how to use this tag set. This directive is used to described
static lists of options and is contained
within the [param](#tool-inputs-param) directive when the ``type`` attribute
value is ``select`` (i.e. ``<param type="select" ...>``).

### Example

```xml
<param name="style" type="select" label="with flavor">
    <option value="num">Numerical sort</option>
    <option value="gennum">General numeric sort</option>
    <option value="alpha">Alphabetical sort</option>
</param>
```

An option can also be annotated with ``selected="true"`` to specify a
default option.

```xml
<param name="col" type="select" label="From">
    <option value="0" selected="true">Column 1 / Sequence name</option>
    <option value="1">Column 2 / Source</option>
    <option value="2">Column 3 / Feature</option>
    <option value="6">Column 7 / Strand</option>
    <option value="7">Column 8 / Frame</option>
</param>
```
]]>
</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="value" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[The value of the
corresponding variable when used the Cheetah template. Also the value that
should be used in building test cases and used when building requests for the
API.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="selected" type="PermissiveBoolean" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">A boolean parameter indicating
if the corresponding option is selected by default (the default is ``false``).
</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ParamConversion">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

A contrived example of a tool that uses this is the test tool
[explicit_conversion.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/explicit_conversion.xml).

This directive is optionally contained within the ``<param>`` tag when the
``type`` attribute value is ``data`` and is used to dynamically generated a converted
dataset for the contained input of the type specified using the ``type`` tag.

]]>
</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name of cheetah variable to create for converted dataset.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">The short extension describing the datatype to convert to - Galaxy must have a datatype converter from the parent input's type to this.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="ParamOptions">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

See [/tools/extract/liftOver_wrapper.xml](https://github.com/galaxyproject/galaxy/blob/master/tools/extract/liftOver_wrapper.xml)
for an example of how to use this tag set. This tag set is optionally contained
within the ``<param>`` tag when the ``type`` attribute value is ``select`` or
``data`` and used to dynamically generated lists of options. This tag set
dynamically creates a list of options whose values can be
obtained from a predefined file stored locally or a dataset selected from the
current history.

There are at least five basic ways to use this tag - four of these correspond to
a ``from_XXX`` attribute on the ``options`` directive and the other is to
exclusively use ``filter``s to populate options.

* ``from_data_table`` - The options for the select list are dynamically obtained
  from a file specified in the Galaxy configuration file
  ``tool_data_table_conf.xml`` or from a Tool Shed installed data manager.
* ``from_dataset`` - The options for the select list are dynamically obtained
  from input dataset selected for the tool from the current history.
* ``from_file`` - The options for the select list are dynamically obtained from
  a file. This mechanis is discourage in favor of the more generic
  ``from_data_table``.
* ``from_parameter`` - The options for the select list are dynamically obtained
  from a parameter.
* Using ``filter``s - various filters can be used to populate options, see
  examples in the [filter](#tool-inputs-param-options-filter) documentation.

### ``from_data_table``

See Galaxy's
[data tables documentation](https://wiki.galaxyproject.org/Admin/Tools/Data%20Tables)
for information on setting up data tables.

Once a data table has been configured and populated, these can be easily
leveraged via tools.

This ``conditional`` block in the
[bowtie2](https://github.com/galaxyproject/tools-devteam/blob/master/tools/bowtie2/bowtie2_wrapper.xml)
wrapper demonstrates using ``from_data_table`` options as an
alternative to local reference data.

```xml
<conditional name="reference_genome">
  <param name="source" type="select" label="Will you select a reference genome from your history or use a built-in index?" help="Built-ins were indexed using default options. See `Indexes` section of help below">
    <option value="indexed">Use a built-in genome index</option>
    <option value="history">Use a genome from the history and build index</option>
  </param>
  <when value="indexed">
    <param name="index" type="select" label="Select reference genome" help="If your genome of interest is not listed, contact the Galaxy team">
      <options from_data_table="bowtie2_indexes">
        <filter type="sort_by" column="2"/>
        <validator type="no_options" message="No indexes are available for the selected input dataset"/>
      </options>
    </param>
  </when>
  <when value="history">
    <param name="own_file" type="data" format="fasta" label="Select reference genome" />
  </when>
</conditional>
```

A minimal example wouldn't even need the ``filter`` or ``validator`` above, but
they are frequently nice features to add to your wrapper and can improve the user
experience of a tool.

### ``from_dataset``

The following example is taken from the Mothur tool
[remove.lineage.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tools/mothur/remove.lineage.xml)
and demonstrates generating options from a dataset directly.

```xml
<param name="taxonomy" type="data" format="mothur.seq.taxonomy" label="taxonomy - Taxonomy" help="please make sure your file has no quotation marks in it"/>
<param name="taxons" type="select" size="120" optional="true" multiple="true" label="Browse Taxons from Taxonomy">
    <options from_dataset="taxonomy">
        <column name="name" index="1"/>
        <column name="value" index="1"/>
        <filter type="unique_value" name="unique_taxon" column="1"/>
        <filter type="sort_by" name="sorted_taxon" column="1"/>
    </options>
    <sanitizer>
        <valid initial="default">
            <add preset="string.printable"/>
            <add value=";"/>
            <remove value="&quot;"/>
            <remove value="&apos;"/>
        </valid>
    </sanitizer>
</param>
```

Filters can be used to generate options from dataset directly also as the
example below demonstrates (many more examples are present in the
[filter](#tool-inputs-param-options-filter) documentation).

```xml
<param name="species1" type="select" label="When Species" multiple="false">
    <options>
        <filter type="data_meta" ref="input1" key="species" />
    </options>
</param>
```

### ``from_file``

The following example is for Blast databases. In this example users maybe select
a database that is pre-formatted and cached in Galaxy clusters. When a new
dataset is available, admins must add the database to the local file named
"blastdb.loc". All such databases in that file are included in the options of
the select list. For a local instance, the file (e.g. ``blastdb.loc`` or
``alignseq.loc``) must be stored in the configured
[tool_data_path](https://github.com/galaxyproject/galaxy/tree/master/tool-data)
directory. In this example, the option names and values are taken from column 0
of the file.

```xml
<param name="source_select" type="select" display="radio" label="Choose target database">
    <options from_file="blastdb.loc">
        <column name="name" index="0"/>
        <column name="value" index="0"/>
    </options>
</param>
```

In general, ``from_file`` should be considered deprecated and  ``from_data_table``
should be prefered.

### ``from_parameter``

This variant of the ``options`` directive is discouraged because it exposes
internal Galaxy structures. See the older
[bowtie](https://github.com/galaxyproject/tools-devteam/blob/master/tools/bowtie_wrappers/bowtie_wrapper.xml)
wrappers for an example of these.

### Other Ways to Dynamically Generate Options

Though deprecated and discouraged, [code](#tool-code) blocks can also be
used to generate dynamic options.

]]>
</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="OptionsElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="from_dataset" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_dataset</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_file" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_data_table" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_data_table</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_parameter" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for from_parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="options_filter_attribute" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for options_filter_attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transform_lines" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for transform_lines</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startswith" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Documentation for startswith</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="OptionsElement">
    <xs:choice>
      <xs:element name="filter" type="Filter" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="column" type="Column" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="validator" type="Validator" minOccurs="0" maxOccurs="1"/>
      <xs:element name="file" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation xml:lang="en">Documentation for file</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Column">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Optionally contained within an
``<options>`` tag set - specifies columns used in building select options from a
file stored locally (i.e. index or tool data) or a dataset in the
current history.

Any number of columns may be described, but at least one must be given the name
``value`` and it will serve as the value of this parameter in the Cheetah
template and elsewhwere (e.g. in API for instance).

If a column named ``name`` is defined, this too has special meaning and it will
be the value the tool form user sees for each option. If no ``name`` column
appears, ``value`` will serve as the name.

### Examples

The following fragment shows options from the dataset in the current history
that has been selected as the value of the parameter named ``input1``.

```xml
<options from_dataset="input1">
    <column name="name" index="0"/>
    <column name="value" index="0"/>
</options>
```

The [interval2maf](https://github.com/galaxyproject/galaxy/blob/dev/tools/maf/interval2maf.xml)
tool makes use of this tag with files from a history, and the
[star_fusion](https://github.com/galaxyproject/tools-iuc/blob/master/tools/star_fusion/star_fusion.xml)
tool makes use of this to reference a data table.
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name given to the column with index
``index``, the names ``name`` and ``value`` have special meaning as described
above.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="index" type="xs:decimal" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">0-based index of the column in the
target file.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Validator">
    <xs:annotation>

      <xs:documentation xml:lang="en"><![CDATA[

See the
[annotation_profiler](https://github.com/galaxyproject/tools-devteam/blob/master/tools/annotation_profiler/annotation_profiler.xml)
tool for an example of how to use this tag set. This tag set is contained within
the <param> tag set - it applies a validator to the containing parameter.

### Examples

The following demonstrates a simple validator ``unspecified_build`` ensuring
that a dbkey is present on the selected dataset. This example is taken from the
[extract_genomic_dna](https://github.com/galaxyproject/tools-iuc/blob/master/tools/extract_genomic_dna/extract_genomic_dna.xml#L42)
tool.

```xml
<param name="input" type="data" format="gff,interval" label="Fetch sequences for intervals in">
    <validator type="unspecified_build" />
</param>
```

Along the same line, the following example taken from
[samtools_mpileup](https://github.com/galaxyproject/tools-devteam/blob/master/tool_collections/samtools/samtools_mpileup/samtools_mpileup.xml)
ensures that a dbkey is present and that FASTA indices in the ``fasta_indexes``
tool data table are present.

```xml
<param format="bam" label="BAM file(s)" name="input_bam" type="data" min="1" multiple="True">
    <validator type="unspecified_build" />
    <validator type="dataset_metadata_in_data_table" metadata_name="dbkey" table_name="fasta_indexes" metadata_column="1"
               message="Sequences are not currently available for the specified build." />
</param>
```

In this older, somewhat deprecated example - a genome build of the dataset must
be stored in Galaxy clusters and the name of the genome (``dbkey``) must be one
of the values in the first column of file ``alignseq.loc`` - that could be
expressed with the validator. In general, ``dataset_metadata_in_file`` should be
considered deprecated in favor of

```xml
<validator type="dataset_metadata_in_file"
           filename="alignseq.loc"
           metadata_name="dbkey"
           metadata_column="1"
           message="Sequences are not currently available for the specified build."
           split=" "
           line_startswith="seq" />
```

A very common validator is simply ensure a Python expression is valid for a
specified value. In the following example - paths/names that downstream tools
use in filenames may not contain ``..``.

```xml
<validator type="expression" message="No two dots (..) allowed">'..' not in value</validator>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="ValidatorType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[The list of supported
validators is in the ``validator_types`` dictionary in
[/lib/galaxy/tools/parameters/validation.py](https://github.com/galaxyproject/galaxy/blob/dev/lib/galaxy/tools/parameters/validation.py).
Valid values include: ``expression``, ``regex``, ``in_range``, ``length``,
``metadata``, ``unspecified_build``, ``no_options``, ``empty_field``,
``dataset_metadata_in_file``, ``dataset_metadata_in_data_table``,
``dataset_ok_validator``]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="message" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">
The error message displayed on the tool form if validation fails. </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="check" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Comma-seperated list of metadata
fields to check for if type is ``metadata``. If not specified, all non-optional
metadata fields will be checked unless they appear in the list of fields
specified by the ``skip`` attribute.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="table_name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Tool data table name to check against
if ``type`` is ``dataset_metadata_in_tool_data``. See the documentation for
[tool data tables](https://wiki.galaxyproject.org/Admin/Tools/Data%20Tables)
and [data managers](https://wiki.galaxyproject.org/Admin/Tools/DataManagers) for
more information.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="filename" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Tool data filename to check against
if ``type`` is ``dataset_metadata_in_file``. File should be present Galaxy's
``tool-data`` directory.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="metadata_name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Target metadata attribute name for
``dataset_metadata_in_data_table`` and ``dataset_metadata_in_file`` options.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="metadata_column" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Target column for metadata attribute
in ``dataset_metadata_in_data_table`` and ``dataset_metadata_in_file`` options.
This can be an integer index to the column or a column name.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="line_startswith" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used to indicate lines in the file
being used for validation start with a this attribute value.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min" type="xs:decimal">
          <xs:annotation>
            <xs:documentation xml:lang="en">When the ``type`` attribute value is
``in_range`` - this is the minimum number allowed.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max" type="xs:decimal">
          <xs:annotation>
            <xs:documentation xml:lang="en">When the ``type`` attribute value is
``in_range`` - this is the maximum number allowed.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="exclude_min" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">When the ``type`` attribute value is
``in_range`` - this boolean indicates if the ``min`` value is allowed.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="exclude_max" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">When the ``type`` attribute value is
``in_range`` - this boolean indicates if the ``max`` value is allowed.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="split" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">If ``type`` is `dataset_metadata_in_file``,
this attribute is the column separator to use for values in the specified file.
This default is ``\t`` and due to a bug in older versions of Galaxy, should
not be modified.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skip" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Comma-seperated list of metadata
fields to skip if type is ``metadata``. If not specified, all non-optional
metadata fields will be checked unless ``check`` attribute is specified.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="Sanitizer">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

See
[/tools/filters/grep.xml](https://github.com/galaxyproject/galaxy/blob/dev/tools/filters/grep.xml)
for a typical example of how to use this tag set. This tag set is used to
replace the basic parameter sanitization with custom directives. This tag set is
contained within the ``<param>`` tag set - it contains a set of ``<valid>`` and
``<mapping>`` tags.

### Examples

This example replaces the invalid character default of ``X`` with the empty
string (so invalid characters are effectively dropped instead of replaced with
``X``) and indicates the only valid characters for this input are ASCII letters,
ASCII digits, and ``_``.

```
<param name="mystring" type="text" label="Say something interesting">
    <sanitizer invalid_char="">
        <valid initial="string.letters,string.digits"><add value="_" /> </valid>
    </sanitizer>
</param>
```

This example allows many more valid characters and specifies that ``&`` will just
be dropped from the input.

```
<sanitizer>
    <valid initial="string.printable">
        <remove value="&apos;"/>
    </valid>
    <mapping initial="none">
        <add source="&apos;" target=""/>
    </mapping>
</sanitizer>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="SanitizerElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="sanitize" type="PermissiveBoolean" default="true">
      <xs:annotation>
        <xs:documentation xml:lang="en">This boolean parameter determines if the
input is sanitized at all (the default is ``true``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="invalid_char" type="xs:string" default="X">
      <xs:annotation>
        <xs:documentation xml:lang="en">The attribute specifies the character
used as a replacement for invalid characters.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="SanitizerElement">
    <xs:choice>
      <xs:element name="valid" type="SanitizerValid"/>
      <xs:element name="mapping" type="SanitizerMapping"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="SanitizerValid">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the
``<sanitizer>`` tag set, these are used to specify a list of allowed characters.
Contains ``<add>`` and ``<remove>`` tags.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="SanitizerValidElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="initial" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This describes the initial characters to
allow as valid, the default is ``string.letters + string.digits + " -=_.()/+*^,:?!"``</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerValidAdd">
    <xs:annotation>
      <xs:documentation xml:lang="en">This directive is used to add individual
characters or preset lists of characters. Character must not be allowed as a
valid input for the mapping to occur. Preset lists include default and none as well as those available from string.* (e.g. ``string.printable``).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="preset" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Add target characters from the list of valid characters (e.g. ``string.printable``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Add a character to the list of valid characters.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerValidRemove">
    <xs:annotation>
      <xs:documentation xml:lang="en">This directive is used to remove
individual characters or preset lists of characters.
Character must not be allowed as a valid input for the mapping to occur.
Preset lists include default and none as well as those available from string.* (e.g. ``string.printable``).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="preset" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Remove characters from the list of valid characters (e.g. ``string.printable``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">A character to remove from the list of valid characters.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="SanitizerValidElement">
    <xs:choice>
      <xs:element name="add" type="SanitizerValidAdd"/>
      <xs:element name="remove" type="SanitizerValidRemove"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="SanitizerMapping">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <sanitizer> tag set. Used to specify a mapping of disallowed character to replacement string. Contains <add> and <remove> tags.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="SanitizerMappingElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="initial" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">initial character mapping (default is ``galaxy.util.mapped_chars``)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerMappingAdd">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Use to add character mapping during sanitization. Character must not be allowed as a valid input for the mapping to occur.]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Replace all occurrences of this character with the string of ``target``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="target" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Replace all occurrences of ``source`` with this string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SanitizerMappingRemove">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Use to remove character mapping during sanitization.]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Character to remove from mapping.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="SanitizerMappingElement">
    <xs:choice>
      <xs:element name="add" type="SanitizerMappingAdd" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="remove" type="SanitizerMappingRemove" minOccurs="0" maxOccurs="unbounded"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Filter">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Optionally contained within an
``<options>`` tag set - filter out values obtained from a locally stored file (e.g.
a tool data table) or a dataset in the current history.

### Examples

The following example from Mothur's
[remove.groups.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tools/mothur/remove.groups.xml)
tool demonstrates filtering a select list based on the metadata of an input to
to the tool.

```xml
<param name="group_in" type="data" format="mothur.groups,mothur.count_table" label="group or count table - Groups"/>
<param name="groups" type="select" label="groups - Pick groups to remove" multiple="true" optional="false">
    <options>
        <filter type="data_meta" ref="group_in" key="groups"/>
    </options>
</param>
```

This more advanced example, taken from Mothur's
[remove.linage.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tools/mothur/remove.lineage.xml)
tool demonstrates using filters to sort a list and remove duplicate entries.

```xml
<param name="taxonomy" type="data" format="mothur.cons.taxonomy" label="constaxonomy - Constaxonomy file. Provide either a constaxonomy file or a taxonomy file" help="please make sure your file has no quotation marks in it"/>
<param name="taxons" type="select" size="120" optional="true" multiple="true" label="Browse Taxons from Taxonomy">
    <options from_dataset="taxonomy">
        <column name="name" index="2"/>
        <column name="value" index="2"/>
        <filter type="unique_value" name="unique_taxon" column="2"/>
        <filter type="sort_by" name="sorted_taxon" column="2"/>
    </options>
    <sanitizer>
        <valid initial="default">
            <add preset="string.printable"/>
            <add value=";"/>
            <remove value="&quot;"/>
            <remove value="&apos;"/>
        </valid>
    </sanitizer>
</param>
```

This example taken from the
[hisat2](https://github.com/galaxyproject/tools-iuc/blob/master/tools/hisat2/hisat2.xml)
tool demonstrates filtering values from a tool data table.

```xml
<param help="If your genome of interest is not listed, contact the Galaxy team" label="Select a reference genome" name="index" type="select">
    <options from_data_table="hisat2_indexes">
        <filter column="2" type="sort_by" />
        <validator message="No genomes are available for the selected input dataset" type="no_options" />
    </options>
</param>
```

The
[gemini_load.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tools/gemini/gemini_load.xml)
tool demonstrates adding values to an option list using ``filter``s.

```xml
<param name="infile" type="data" format="vcf" label="VCF file to be loaded in the GEMINI database" help="Only build 37 (aka hg19) of the human genome is supported.">
    <options>
        <filter type="add_value" value="hg19" />
        <filter type="add_value" value="Homo_sapiens_nuHg19_mtrCRS" />
        <filter type="add_value" value="hg_g1k_v37" />
    </options>
</param>
```

While this fragment from maf_to_interval.xml demonstrates removing items.

```xml
<param name="species" type="select" label="Select additional species"
       display="checkboxes" multiple="true"
       help="The species matching the dbkey of the alignment is always included.
       A separate history item will be created for each species.">
    <options>
        <filter type="data_meta" ref="input1" key="species" />
        <filter type="remove_value" meta_ref="input1" key="dbkey" />
    </options>
</param>
```

This example taken from
[snpSift_dbnsfp.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tool_collections/snpsift/snpsift_dbnsfp/snpSift_dbnsfp.xml)
demonstrates splitting up strings into multiple values.

```xml
<param name="annotations" type="select" multiple="true" display="checkboxes" label="Annotate with">
    <options from_data_table="snpsift_dbnsfps">
        <column name="name" index="4"/>
        <column name="value" index="4"/>
        <filter type="param_value" ref="dbnsfp" column="3" />
        <filter type="multiple_splitter" column="4" separator=","/>
    </options>
</param>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="type" type="FilterType" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
These values are defined in the module
[/lib/galaxy/tools/parameters/dynamic_options.py](https://github.com/galaxyproject/galaxy/blob/master/lib/galaxy/tools/parameters/dynamic_options.py)
in the ``filter_types`` dictionary. Currently defined values are: ``data_meta``,
``param_value``, ``static_value``, ``unique_value``, ``multiple_splitter``,
``attribute_value_splitter``, ``add_value``, ``remove_value``, and
``sort_by``]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="column" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Column targeted by this filter - this
attribute is unused and invalid if ``type`` is ``add_value`` or ``remove_value``.
This can be a column index or a column name.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name displayed for value to add (only
used with ``type`` of ``add_value``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">The attribute name of the reference file
(tool data) or input dataset. Only used when ``type`` is
``data_meta`` (required), ``param_value`` (required), or ``remove_value``
(optional).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="key" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">When ``type`` is ``data_meta``, ``param_value``,
or ``remove_value`` - this is the name of the metadata key of ref to filter by.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multiple" type="PermissiveBoolean" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[For types ``data_meta`` and
``remove_value``, whether option values are multiple. Columns will be split by
separator. Defaults to ``false``.]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="separator" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[When ``type`` is ``data_meta``,
``multiple_splitter``, or ``remove_value`` - this is used to split one value
into multiple parts. When ``type`` is ``data_meta`` or ``remove_value`` this is
only used if ``multiple`` is set to ``true``.]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keep" type="PermissiveBoolean" default="true">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``true``, keep columns matching the
value, if ``false`` discard columns matching the value. Used when ``type`` is
either ``static_value`` or ``param_value``.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Target value of the operations - has
slightly different meanings depending on ``type``. For instance when ``type`` is
``add_value`` it is the value to add to the list and when ``type`` is
``static_value`` it is the value compared against.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref_attribute" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Only used when ``type`` is
``param_value``. Period (``.``) separated attribute chain of input (``ref``)
attributes to use as value for filter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="index" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en">Used when ``type`` is ``add_value``, it
is the index into the list to add the option to. If not set, the option will be
added to the end of the list.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Outputs">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Container tag set for the ``<data>`` and ``<collection>`` tag sets.
The files and collections created by tools as a result of their execution are
named by Galaxy. You specify the number and type of your output files using the
contained ``<data>`` and ``<collection>`` tags. These may be passed to your tool
executable through using line variables just like the parameters described in
the ``<inputs>`` documentation.
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="OutputsElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="OutputsElement">
    <xs:choice>
      <xs:element name="data" type="Data"/>
      <xs:element name="collection" type="Collection" />
    </xs:choice>
  </xs:group>
  <xs:group name="DataElement">
    <xs:choice>
      <xs:element name="change_format" type="ChangeFormat"/>
      <xs:element name="filter" type="OutputFilter" />
      <xs:element name="discover_datasets" type="OutputDiscoverDatasets" />
      <xs:element name="actions" type="Actions"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Data">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set is contained within the ``<outputs>`` tag set, and it defines the
output data description for the files resulting from the tool's execution. The
value of the attribute ``label`` can be acquired from input parameters or metadata
in the same way that the command line parameters are (discussed in the
<command> tag set section above).

### Examples

The following will create a variable called ``$out_file1`` with data type
``pdf``.

```xml
<outputs>
    <data format="pdf" name="out_file1" />
</outputs>
```

The valid values for format can be found in
[/config/datatypes_conf.xml.sample](https://github.com/galaxyproject/galaxy/blob/dev/config/datatypes_conf.xml.sample).

The following will create a dataset in the history panel whose data type is the
same as that of the input dataset selected (and named ``input1``) for the tool.

```xml
<outputs>
    <data format_source="input1" name="out_file1" metadata_source="input1"/>
</outputs>
```

The following will create datasets in the history panel, setting the output data
type to be the same as that of an input dataset named by the ``format_source``
attribute. Note that a conditional name is not included, so 2 separate
conditional blocks should not contain parameters with the same name.

```xml
<inputs>
    <!-- fasta may be an aligned fasta that subclasses Fasta -->
    <param name="fasta" type="data" format="fasta" label="fasta - Sequences"/>
    <conditional name="qual">
        <param name="add" type="select" label="Trim based on a quality file?" help="">
            <option value="no">no</option>
            <option value="yes">yes</option>
        </param>
        <when value="no"/>
        <when value="yes">
            <!-- qual454, qualsolid, qualillumina -->
            <param name="qfile" type="data" format="qual" label="qfile - a quality file"/>
        </when>
    </conditional>
</inputs>
<outputs>
    <data format_source="fasta" name="trim_fasta"
          label="${tool.name} on ${on_string}: trim.fasta"/>
    <data format_source="qfile" name="trim_qual"
          label="${tool.name} on ${on_string}: trim.qual">
        <filter>qual['add'] == 'yes'</filter>
    </data>
</outputs>
```

Assume that the tool includes an input parameter named ``database`` which is a
select list (as shown below). Also assume that the user selects the first option
in the ``$database`` select list. Then the following will ensure that the tool
produces a tabular data set whose associated history item has the label ``Blat
on Human (hg18)``.

```xml
<inputs>
    <param format="tabular" name="input" type="data" label="Input stuff"/>
    <param type="select" name="database" label="Database">
        <option value="hg18">Human (hg18)</option>
        <option value="dm3">Fly (dm3)</option>
    </param>
</inputs>
<outputs>
    <data format="input" name="output" label="Blat on ${database.value_label}" />
</outputs>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DataElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <!-- TODO: add a unique constraint for action. -->
    <xs:attribute name="name" type="xs:string">
        <xs:annotation>
          <xs:documentation xml:lang="en"><![CDATA[Name for this output. This
``name`` is used as the Cheetah variable containing the Galaxy assigned output
path in ``command`` and ``configfile`` elements. The name should not contain
pipes or periods (e.g. ``.``).]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auto_format" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

If ``true``, this output will sniffed and its format determined automatically by Galaxy.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">The short name for the output datatype.
The valid values for format can be found in
[/config/datatypes_conf.xml.sample](https://github.com/galaxyproject/galaxy/blob/dev/config/datatypes_conf.xml.sample)
(e.g. ``format="pdf"`` or ``format="fastqsanger"``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This sets the data type of the output file to be the same format as that of a tool input dataset.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="metadata_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This copies the metadata information
from the tool's input dataset. This is particularly useful for interval data
types where the order of the columns is not set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="label" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

This will be the name of the history item for the output data set. The string
can include structure like ``${<some param name>.<some attribute>}``, as
discussed for command line parameters in the ``<command>`` tag set section
above. The default label is ``${tool.name} on ${on_string}``.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from_work_dir" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Relative path to a file produced by the
tool in its working directory. Output's contents are set to this file's
contents.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hidden" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en">Boolean indicating whether to hide
dataset in the history view. (Default is ``false``.)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:group name="CollectionElement">
    <xs:choice>
      <xs:element name="data" type="Data" />
      <xs:element name="discover_datasets" type="OutputCollectionDiscoverDatasets" />
      <xs:element name="filter" type="OutputFilter" />
    </xs:choice>
  </xs:group>

  <xs:complexType name="Collection">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set is contained within the ``<outputs>`` tag set, and it defines the
output dataset collection description resulting from the tool's execution. The
value of the attribute ``label`` can be acquired from input parameters or
metadata in the same way that the command line parameters are (discussed in the
[command](#tool-command) directive).

Creating collections in tools is covered in-depth in
[planemo's documentation](https://planemo.readthedocs.io/en/latest/writing_advanced.html#creating-collections).

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="CollectionElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
        <xs:annotation>
          <xs:documentation xml:lang="en"><![CDATA[Name for this output. This
``name`` is used as the Cheetah variable containing the Galaxy assigned output
path in ``command`` and ``configfile`` elements. The name should not contain
pipes or periods (e.g. ``.``).]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Collection type for output (e.g. ``paired``, ``list``, or ``list:list``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="label" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[

This will be the name of the history item for the output data set. The string
can include structure like ``${<some param name>.<some attribute>}``, as
discussed for command line parameters in the ``<command>`` tag set section
above. The default label is ``${tool.name} on ${on_string}``.

]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This is the name of input collection or
dataset to derive output dataset collection's element's format/datatype from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type_source" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This is the name of input collection to
derive collection's type (e.g. ``collection_type``) from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="structured_like" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This is the name of input collection or
dataset to derive "structure" of the output from (output element count and
identifiers). For instance, if the referenced input has three ordered items with
identifiers ``sample1``, ``sample2``,  and ``sample3``</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inherit_format" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``structured_like`` is set, inherit
format of outputs from format of corresponding input.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="OutputFilter">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
The ``<data>`` tag can contain a ``<filter>`` tag which includes a Python code
block to be executed to test whether to include this output in the outputs the
tool ultimately creates. If the code, when executed, returns ``True``,
the output dataset is retained. In these code blocks the tool parameters appear
as Python variables and are thus referred to without the $ used for the Cheetah
template (used in the ``<command>`` tag). Variables that are part of
conditionals are accessed using a hash named after the conditional.

### Example

```xml
    <inputs>
      <param type="data" format="fasta" name="reference_genome" label="Reference genome" />
      <param type="data" format="bam" name="input_bam" label="Aligned reads" />
      <conditional name="options">
        <param label="Use advanced options" name="selection_mode" type="select">
          <option selected="True" value="defaults">Use default options</option>
          <option value="advanced">Use advanced options</option>
        </param>
        <when value="defaults"> </when>
        <when value="advanced">
          <param name="vcf_output" type="boolean" checked="false" label="VCF output"
            truevalue="--vcf" falsevalue="" />
        </when>
      <conditional>
    </inputs>
    <outputs>
      <data format="txt" label="Alignment report on ${on_string}" name="output_txt" />
      <data format="vcf" label="Variant summary on ${on_string}" name="output_vcf">
          <filter>options['selection_mode'] == 'advanced' and options['vcf_output']</filter>
      </data>
    </outputs>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="OutputDiscoverDatasets">
     <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

Describe datasets to dynamically collect after the job complete.

There are many simple tools with examples of this element distributed with
Galaxy, including:

* https://github.com/galaxyproject/galaxy/tree/master/test/functional/tools/multi_output.xml
* https://github.com/galaxyproject/galaxy/tree/master/test/functional/tools/multi_output_assign_primary.xml
* https://github.com/galaxyproject/galaxy/tree/master/test/functional/tools/multi_output_configured.xml

More information can be found on Planemo's documentation for
[multiple output files](https://planemo.readthedocs.io/en/latest/writing_advanced.html#multiple-output-files).
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="pattern" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Regular expression used to find filenames and parse dynamic properties.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Directory (relative to working directory) to search for files.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``ext``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ext" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``format``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="visible" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Indication if this dataset is visible in output history. This defaults to ``false``, but probably shouldn't - be sure to set to ``true`` if that is your intention.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="assign_primary_output" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Replace the primary dataset described by the parameter ``data`` parameter with the first output discovered.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="OutputCollectionDiscoverDatasets">
     <xs:annotation>
       <xs:documentation xml:lang="en"><![CDATA[

This tag allows one to describe the datasets contained within an output
collection dynamically, such that the outputs are "discovered" based on regular
expressions after the job is complete.

There are many simple tools with examples of this element distributed with
Galaxy, including:

* https://github.com/galaxyproject/galaxy/blob/master/test/functional/tools/collection_split_on_column.xml
* https://github.com/galaxyproject/galaxy/blob/master/test/functional/tools/collection_creates_dynamic_list_of_pairs.xml
* https://github.com/galaxyproject/galaxy/blob/master/test/functional/tools/collection_creates_dynamic_nested.xml

]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="pattern" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Regular expression used to find filenames and parse dynamic properties.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Directory (relative to working directory) to search for files.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``ext``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ext" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Format (or datatype) of discovered datasets (an alias with ``format``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="visible" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Indication if this dataset is visible in output history. This defaults to ``false``, but probably shouldn't - be sure to set to ``true`` if that is your intention.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Actions">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

The ``actions`` directive allows tools to dynamically take actions related to an
``output`` either unconditionally or conditionally based on inputs. These
actions currently include setting metadata values and the output's data format.

The examples below will demonstrate that the ``actions`` tag contains child
``conditional`` tags. The these conditionals are met, additional ``action``
directives below the conditional are apply to the ``data`` output.

### Metadata

The ``<actions>`` in the Bowtie 2 wrapper is used in lieu of the deprecated
``<code>`` tag to set the ``dbkey`` of the output dataset. In
[bowtie2_wrapper.xml](https://github.com/galaxyproject/tools-devteam/blob/master/tools/bowtie2/bowtie2_wrapper.xml)
(see below), according to the first action block, if the
```reference_genome.source`` is ``indexed`` (not ``history``), then it will assign
the ``dbkey`` of the output file to be the same as that of the reference file. It
does this by looking at through the data table and finding the entry that has the
value that's been selected in the index dropdown box as column 1 of the loc file
entry and using the dbkey, in column 0 (ignoring comment lines (starting with #)
along the way).

If ``reference_genome.source`` is ``history``, it pulls the ``dbkey`` from the
supplied file.

```xml
<data format="bam" name="output" label="${tool.name} on ${on_string}: aligned reads (sorted BAM)">
  <filter>analysis_type['analysis_type_selector'] == "simple" or analysis_type['sam_opt'] is False</filter>
  <actions>
    <conditional name="reference_genome.source">
      <when value="indexed">
        <action type="metadata" name="dbkey">
          <option type="from_data_table" name="bowtie2_indexes" column="1" offset="0">
            <filter type="param_value" column="0" value="#" compare="startswith" keep="False"/>
            <filter type="param_value" ref="reference_genome.index" column="0"/>
          </option>
        </action>
      </when>
      <when value="history">
        <action type="metadata" name="dbkey">
          <option type="from_param" name="reference_genome.own_file" param_attribute="dbkey" />
        </action>
      </when>
    </conditional>
  </actions>
</data>
```

### Format

The Bowtie 2 example also demonstrates conditionally setting an output format
based on inputs, as shown below:

```xml
<data format="fastqsanger" name="output_unaligned_reads_r" label="${tool.name} on ${on_string}: unaligned reads (R)">
    <filter>( library['type'] == "paired" or library['type'] == "paired_collection" ) and library['unaligned_file'] is True</filter>
    <actions>
        <conditional name="library.type">
            <when value="paired">
                <action type="format">
                    <option type="from_param" name="library.input_2" param_attribute="ext" />
                </action>
            </when>
            <when value="paired_collection">
                <action type="format">
                    <option type="from_param" name="library.input_1" param_attribute="reverse.ext" />
                </action>
            </when>
        </conditional>
    </actions>
</data>
```

### Unconditional Actions and Column Names

For a static file that contains a fixed number of columns, it is straight forward:

```xml
<outputs>
    <data format="tabular" name="table">
        <actions>
            <action name="column_names" type="metadata" default="Firstname,Lastname,Age" />
        </actions>
    </data>
</outputs>
```

It may also be necessary to use column names based on a variable from another
input file. This is implemented in the
[htseq-count](https://github.com/galaxyproject/tools-iuc/blob/master/tools/htseq_count/htseq-count.xml)
and
[featureCounts](https://github.com/galaxyproject/tools-iuc/blob/master/tools/featurecounts/featurecounts.xml)
wrappers:

```xml
<inputs>
    <data name="input_file" type="data" multiple="false">
</inputs>
<outputs>
    <data format="tabular" name="output_short">
        <actions>
            <action name="column_names" type="metadata" default="Geneid,${input_file.name}" />
        </actions>
    </data>
</outputs>
```

Or in case of multiple files:

```xml
<inputs>
    <data name="input_files" type="data" multiple="true">
</inputs>
<outputs>
    <data format="tabular" name="output_short">
        <actions>
            <action name="column_names" type="metadata" default="Geneid,${','.join([ a.name for a in $input_files ])}" />
        </actions>
    </data>
</outputs>
```

### Unconditional Actions - An Older Example

The first approach above to setting ``dbkey`` based on tool data tables is
prefered, but an older example using so called "loc files" directly is found
below.

In addition to demonstrating this lower-level direct access of .loc files, it
demonstrates an unconditional action. The second block would not be needed for
most cases - it was required in this tool to handle the specific case of a small
reference file used for functional testing. It says that if the dbkey has been
set to ``equCab2chrM`` (which is what the ```<filter type="metadata_value"...
column="1" />`` tag does), then it should be changed to ``equCab2`` (which is the
``<option type="from_param" ... column="0" ...>`` tag does).

```xml
<actions>
   <conditional name="refGenomeSource.genomeSource">
      <when value="indexed">
           <action type="metadata" name="dbkey">
            <option type="from_file" name="bowtie_indices.loc" column="0" offset="0">
               <filter type="param_value" column="0" value="#" compare="startswith" keep="False"/>
               <filter type="param_value" ref="refGenomeSource.index" column="1"/>
            </option>
         </action>
       </when>
    </conditional>
    <!-- Special casing equCab2chrM to equCab2 -->
    <action type="metadata" name="dbkey">
        <option type="from_param" name="refGenomeSource.genomeSource" column="0" offset="0">
            <filter type="insert_column" column="0" value="equCab2chrM"/>
            <filter type="insert_column" column="0" value="equCab2"/>
            <filter type="metadata_value" ref="output" name="dbkey" column="1" />
        </option>
    </action>
</actions>
```
]]>
</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ActionsElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="ActionsElement">
    <xs:choice>
      <xs:element name="action" type="Action"/>
      <xs:element name="conditional" type="ActionsConditional"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Action">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This directive is contained within an output ``data``'s  ``actions`` directive
(either directly or beneath a parent ``conditional`` tag). This directive
describes modifications to either the output's format or metadata (based on
whether ``type`` is ``format`` or ``metadata``).

See [actions](#tool-outputs-data-actions) documentation for examples
of this directive.

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="option" type="ActionsOption" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="ActionType" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Type of action (either ``format`` or
``metadata`` currently).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``type="metadata"``, the name of the
metadata element.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="default" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">If ``type="format"``, the default format
if none of the nested options apply.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ActionsOption">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="filter" type="ActionsConditionalFilter" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="ActionsOptionType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="column" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="offset" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="param_attribute" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ActionsConditional">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This directive is contained within an output ``data``'s  ``actions`` directive.
This directive describes the state of the inputs required to apply an ``action``
(specified as children of the child ``when`` directives to this element) to an
output.

See [actions](#tool-outputs-data-actions) documentation for examples
of this directive.

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
        <xs:element name="when" type="ActionsConditionalWhen" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name of the input parameter to base
conditional logic on. The value of this parameter will be matched against nested
``when`` directives.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ActionsConditionalWhen">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

See [actions](#tool-outputs-data-actions) documentation for examples
of this directive.

      ]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="action" type="Action" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Value to match conditional input value
against.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datatype_isinstance" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en">Datatype to match against (if ``value`` is unspecified). This should be the short string describing the format (e.g. ``interval``).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ActionsConditionalFilter">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:attribute name="type" type="ActionsConditionalFilterType" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compare" type="CompareType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="column" type="xs:integer">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keep" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cast" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="param_attribute" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="separator" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strip" type="PermissiveBoolean">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="old_column" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="old_value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="new_column" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="new_value" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EnvironmentVariables">
    <xs:annotation>
      <xs:documentation xml:lang="en">
This directive should contain one or more ``environment_variable`` definition.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="environment_variable" type="EnvironmentVariable" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="EnvironmentVariable">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This directive defines an environment variable that will be available when the
tool executes. The body should be a Cheetah template block that may reference
the tool's inputs as demonstrated below.

### Example

The following demonstrates a couple ``environment_variable`` definitions.

```xml
<environment_variables>
    <environment_variable name="INTVAR">$inttest</environment_variable>
    <environment_variable name="IFTEST">#if int($inttest) == 3
ISTHREE
#else#
NOTTHREE
#end if#</environment_variable>
    </environment_variables>
</environment_variables>
```

If these environment variables are used in another Cheetah context, such as in
the ``command`` block, the ``$`` used indicate shell expansion of a variable
should be escaped with a ``\`` so prevent it from being evaluated as a Cheetah
variable instead of shell variable.

```xml
<command>
    echo "\$INTVAR"  >  $out_file1;
    echo "\$IFTEST"  >> $out_file1;
</command>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of the environment variable to
define.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ConfigFiles">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[See
[xy_plot.xml](https://github.com/galaxyproject/tools-devteam/blob/master/tools/xy_plot/xy_plot.xml)
for an example of how this tag set is used in a tool. This tag set is a
container for ``<configfile>`` and ``<inputs>`` tag sets - which can be used
to setup configuration files for use by tools.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ConfigFilesElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:group name="ConfigFilesElement">
    <xs:choice>
      <xs:element name="inputs" type="ConfigInputs"/>
      <xs:element name="configfile" type="ConfigFile"/>
    </xs:choice>
  </xs:group>

  <xs:complexType name="ConfigFile">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set is contained within the ``<configfiles>`` tag set. It allows for
the creation of a temporary file for file-based parameter transfer.

*Example*

The following is taken from the [xy_plot.xml](https://github.com/galaxyproject/tools-devteam/blob/master/tools/xy_plot/xy_plot.xml)
tool config.

```xml
<configfiles>
    <configfile name="script_file">
      ## Setup R error handling to go to stderr
      options( show.error.messages=F, error = function () { cat( geterrmessage(), file=stderr() ); q( "no", 1, F ) } )
      ## Determine range of all series in the plot
      xrange = c( NULL, NULL )
      yrange = c( NULL, NULL )
      #for $i, $s in enumerate( $series )
          s${i} = read.table( "${s.input.file_name}" )
          x${i} = s${i}[,${s.xcol}]
          y${i} = s${i}[,${s.ycol}]
          xrange = range( x${i}, xrange )
          yrange = range( y${i}, yrange )
      #end for
      ## Open output PDF file
      pdf( "${out_file1}" )
      ## Dummy plot for axis / labels
      plot( NULL, type="n", xlim=xrange, ylim=yrange, main="${main}", xlab="${xlab}", ylab="${ylab}" )
      ## Plot each series
      #for $i, $s in enumerate( $series )
          #if $s.series_type['type'] == "line"
              lines( x${i}, y${i}, lty=${s.series_type.lty}, lwd=${s.series_type.lwd}, col=${s.series_type.col} )
          #elif $s.series_type.type == "points"
              points( x${i}, y${i}, pch=${s.series_type.pch}, cex=${s.series_type.cex}, col=${s.series_type.col} )
          #end if
      #end for
      ## Close the PDF file
      devname = dev.off()
    </configfile>
</configfiles>
```

This file is then used in the ``command`` block of the tool as follows:

```xml
<command>bash "$__tool_directory__/r_wrapper.sh" "$script_file"</command>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Cheetah variable used to reference
the path to the file created with this directive.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ConfigInputs">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

This tag set is contained within the <configfiles> tag set. It tells Galaxy to
write out a JSON representation of the tool parameters .

*Example*

The following will create a cheetah variable that can be evaluated as ``$inputs`` that
will contain the tool parameter inputs.

```xml
<configfiles>
    <inputs name="inputs" />
<configfiles>
```

The following will instead write the inputs to the tool's working directory with
the specified name (i.e. ``inputs.json``).

```xml
<configfiles>
    <inputs name="inputs" filename="inputs.json" />
<configfiles>
```

A contrived example of a tool that uses this is the test tool
[inputs_as_json.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/inputs_as_json.xml).
]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Cheetah variable to populate the path to the inputs JSON file created in
response to this directive.
]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="filename" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Path relative to the working directory of the tool for the inputs JSON file created in response to this directive.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="VersionCommand">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Specifies the command to be run in
order to get the tool's version string. The resulting value will be found in the
"Info" field of the history dataset.

Unlike the [command](#tool-command) tag, with the exception of the string
``$__tool_directory__`` this value is taken as a literal and so there is no
need to escape values like ``$`` and command inputs are not available for variable
substitution.

### Examples

A simple example for a [TopHat](https://ccb.jhu.edu/software/tophat/index.shtml)
tool definition might just be:

```xml
<version_command>tophat -version</version_command>
```

An example that leverages a Python script (e.g. ``count_reads.py``) shipped with
the tool might be:

```xml
<version_command>python $__tool_directory__/count_reads.py</version_command>
```

Examples are included in the test tools directory including:

- [version_command_plain.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/version_command_plain.xml)
- [version_command_tool_dir.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/version_command_tool_dir.xml)
- [version_command_interpreter.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/version_command_interpreter.xml) (*deprecated*)

]]></xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="interpreter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[*Deprecated*: Prefix the version command with an interpreter and the tool directory in order to execute a script shipped with the tool. It is better to just use ``<interpreter> $__tool_directory__/<script_name>``.]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="RequestParameterTranslation">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
        See ~/tools/data_source/ucsc_tablebrowser.xml for an example of how to use this tag set. This tag set is used only in "data_source" tools (the "tool_type" attribute value is "data_source"). This tag set is contained within the <param> tag set - it contains a set of <request_param> tags.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="request_param" minOccurs="0" maxOccurs="unbounded" type="RequestParameter"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="RequestParameter">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <request_param_translation> tag set ( used only in "data_source" tools ) - the external data source application may send back parameter names like "GENOME" which must be translated to "dbkey" in Galaxy.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="RequestParameterElement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="galaxy_name" type="RequestParameterGalaxyNameType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Each of these maps directly to a remote_name value
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote_name" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          The string representing the name of the parameter in the remote data source
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="missing" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          The default value to use for galaxy_name if the remote_name parameter is not included in the request
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="RequestParameterGalaxyNameType">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="URL" />
      <xs:enumeration value="dbkey" />
      <xs:enumeration value="organism" />
      <xs:enumeration value="table" />
      <xs:enumeration value="description" />
      <xs:enumeration value="name" />
      <xs:enumeration value="info" />
      <xs:enumeration value="data_type" />
    </xs:restriction>
  </xs:simpleType>

  <xs:group name="RequestParameterElement">
    <xs:choice>
      <xs:element name="append_param" type="RequestParameterAppend" />
      <xs:element name="value_translation" type="RequestParameterValueTranslation" />
    </xs:choice>
  </xs:group>

  <xs:complexType name="RequestParameterAppend">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Optionally contained within the <request_param> tag set if galaxy_name="URL" - some remote data sources ( e.g., Gbrowse, Biomart ) send parameters back to Galaxy in the initial response that must be added to the value of "URL" prior to Galaxy sending the secondary request to the remote data source via URL.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="value" minOccurs="0" maxOccurs="unbounded" type="RequestParameterAppendValue"/>
    </xs:sequence>
    <xs:attribute name="separator" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The text to use to join the requested parameters together (example ``separator="&amp;"``).
        ]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="first_separator" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The text to use to join the request_param parameters to the first requested parameter (example ``first_separator="?"``).
        ]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="join" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The text to use to join the param name to its value (example ``join="="``).
        ]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RequestParameterAppendValue">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <append_param> tag set - allows for appending a param name / value pair to the value of URL.

Example:

```xml
<request_param_translation>
    <request_param galaxy_name="URL" remote_name="URL" missing="">
        <append_param separator="&amp;" first_separator="?" join="=">
            <value name="_export" missing="1" />
        </append_param>
    </request_param>
</request_param_tranlsation>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
Any valid HTTP request parameter name. The name / value pair must be received from the remote data source and will be appended to the value of URL as something like "&_export=1" (e.g. ``name="_export"``).
]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="missing" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[Must be a valid HTTP request parameter value (e.g. ``missing="1"``).]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RequestParameterValueTranslation">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Optionally contained within the <request_param> tag set the parameter value received from a remote data source may be named differently in Galaxy, and this tag set allows for the value to be appropriately translated.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="value" minOccurs="0" maxOccurs="unbounded" type="RequestParameterValueTranslationValue"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="RequestParameterValueTranslationValue">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Contained within the <value_translation> tag set - allows for changing the data type value to something supported by Galaxy.

Example:

```xml
<request_param_translation>
    <request_param galaxy_name="data_type" remote_name="hgta_outputType" missing="bed" >
        <value_translation>
            <value galaxy_value="tabular" remote_value="primaryTable" />
        </value_translation>
    </request_param>
</request_param_tranlsation>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="galaxy_value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The target value (e.g. for setting data format: the list of supported data formats is contained in the
[/config/datatypes_conf.xml.sample](https://github.com/galaxyproject/galaxy/blob/dev/config/datatypes_conf.xml.sample).
]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote_value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[The value supplied by the remote data source application]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Stdio">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Tools write the bulk of useful data to datasets, but they can also write messages to standard I/O (stdio) channels known as standard output (stdout) and standard error (stderr). Both stdout and stderr are typically written to the executing program's console or terminal. Previous versions of Galaxy checked stderr for execution errors - if any text showed up on stderr, then the tool's execution was marked as failed. However, many tools write messages to stderr that are not errors, and using stderr allows programs to redirect other interesting messages to a separate file. Programs may also exit with codes that indicate success or failure. One convention is for programs to return 0 on success and a non-zero exit code on failure.

Legacy tools (ones with ``profile`` unspecified or a ``profile`` of less than
16.04) will default to checking stderr for errors as described above. Newer
tools will instead treat an exit code other than 0 as an error. The
``detect_error`` on ``command`` can swap between these behaviors but the
``stdio`` directive allows more options in defining error conditions (though
these aren't always intuitive).

With ``stdio`` directive, Galaxy can use regular expressions to scan stdout and
stderr, and it also allows exit codes to be scanned for ranges. The ``<stdio>``
tag has two subtags, ``<regex>`` and ``<exit_code>``, to define regular
expressions and exit code processing, respectively. They are defined below. If a
tool does not have any valid ``<regex>`` or ``<exit_code>`` tags, then Galaxy
will use the previous technique for finding errors.

A note should be made on the order in which exit codes and regular expressions
are applied and how the processing stops. Exit code rules are applied before
regular expression rules. The rationale is that exit codes are more clearly
defined and are easier to check computationally, so they are applied first. Exit
code rules are applied in the order in which they appear in the tool's
configuration file, and regular expressions are also applied in the order in
which they appear in the tool's configuration file. However, once a rule is
triggered that causes a fatal error, no further rules are
checked.]]></xs:documentation>

    </xs:annotation>
    <xs:sequence>
      <xs:group ref="StdioElement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:group name="StdioElement">
    <xs:choice>
      <xs:element name="regex" type="Regex"/>
      <xs:element name="exit_code" type="ExitCode"/>
    </xs:choice>
  </xs:group>

  <xs:complexType name="ExitCode">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Tools may use exit codes to indicate specific execution errors. Many programs use 0 to indicate success and non-zero exit codes to indicate errors. Galaxy allows each tool to specify exit codes that indicate errors. Each <exit_code> tag defines a range of exit codes, and each range can be associated with a description of the error (e.g., "Out of Memory", "Invalid Sequence File") and an error level. The description just describes the condition and can be anything. The error level is either a warning or a fatal error. A warning means that stderr will be updated with the error's description. A fatal error means that the tool's execution will be marked as having an error and the workflow will stop. Note that, if the error level is not supplied, then a fatal error is assumed to have occurred.

The exit code's range can be any consecutive group of integers. More advanced ranges, such as noncontiguous ranges, are currently not supported. Ranges can be specified in the form "m:n", where m is the start integer and n is the end integer. If ":n" is specified, then the exit code will be compared against all integers less than or equal to n. If "m:" is used, then the exit code will be compared against all integers greater than or equal to m. If the exit code matches, then the error level is applied and the error's description is added to stderr. If a tool's exit code does not match any of the supplied <exit_code> tags' ranges, then no errors are applied to the tool's execution.

Note that most Unix and Linux variants only support positive integers 0 to 255 for exit codes. If an exit code falls out of the range 0 to 255, the usual convention is to only use the lower 8 bits for the exit code. The only known exception is if a job is broken into subtasks using the tasks runner and one of those tasks is stopped with a POSIX signal. (Note that signals should be used as a last resort for terminating processes.) In those cases, the task will receive -1 times the signal number. For example, suppose that a job uses the tasks runner and 8 tasks are created for the job. If one of the tasks hangs, then a sysadmin may choose to send the "kill" signal, SIGKILL, to the process. In that case, the task (and its job) will exit with an exit code of -9. More on POSIX signals can be found at https://en.wikipedia.org/wiki/Unix_signal as well as man pages on "signal".

The <exit_code> tag's supported attributes are as follows:

* ``range``: This indicates the range of exit codes to check. The range can be one of the following:
  * ``n``: the exit code will only be compared to n;
  * ``[m:n]``: the exit code must be greater than or equal to m and less than or equal to n;
  * ``[m:]``: the exit code must be greater than or equal to m;
  * ``[:n]``: the exit code must be less than or equal to n.
* ``level``: This indicates the error level of the exit code. The level can have one of two values:
  * ``warning``: If an exit code falls in the given range, then a description of the error will be added to the beginning of stderr. A warning-level error will not cause the tool to fail.
  * ``fatal``: If an exit code falls in the given range, then a description of the error will be added to the beginning of stderr. A fatal-level error will cause the tool to fail. If no level is specified, then the fatal error level will be assumed to have occurred.
* ``description``: This is an optional description of the error that corresponds to the exit code.

The following is an example of the <exit_code> tag:

```xml
<stdio>
    <exit_code range="2"   level="fatal"   description="Out of Memory" />
    <exit_code range="3:5" level="warning" description="Low disk space" />
    <exit_code range="6:"  level="fatal"   description="Bad input dataset" />
</stdio>
```

If the tool returns 0 or 1, then the tool will not be marked as having an error.
If the exit code is 2, then the tool will fail with the description ``Out of
Memory`` added to stderr. If the tool returns 3, 4, or 5, then the tool will not
be marked as having failed, but ``Low disk space`` will be added to stderr.
Finally, if the tool returns any number greater than or equal to 6, then the
description ``Bad input dataset`` will be added to stderr and the tool will be
marked as having failed.

]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="range" type="RangeType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="level" type="LevelType">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en"></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="Regex">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
A regular expression defines a pattern of characters. The patterns include the following:

* ``GCTA``, which matches on the fixed string "GCTA";
* ``[abcd]``, which matches on the characters a, b, c, or d;
* ``[CG]{12}``, which matches on 12 consecutive characters that are C or G;
* ``a.*z``, which matches on the character "a", followed by 0 or more characters of any type, followed by a "z";
* ``^X``, which matches the letter X at the beginning of a string;
* ``Y$``, which matches the letter Y at the end of a string.

There are many more possible regular expressions. A reference to all supported
regular expressions can be found under
[Python Regular Expression Syntax](https://docs.python.org/3/library/re.html#regular-expression-syntax).

A regular expression includes the following attributes:

* ``source``: This tells whether the regular expression should be matched against stdout, stderr, or both. If this attribute is missing or is incorrect, then both stdout and stderr will be checked. The source can be one of the follwing values:
  * ``stdout``: the regular expression will be applied to stdout;
  * ``stderr``: the regular expression will be applied to stderr;
  * ``both``: the regular expression will be applied to both stderr and stdout (which is the default case).
* ``match``: This is the regular expression that will be used to match against stdout and/or stderr. If the <regex> tag does not contain the match attribute, then the <regex> tag will be ignored. The regular expression can be any valid Python regular expression. All regular expressions are performed case insensitively. For example, if match contains the regular expression "actg", then the regular expression will match against "actg", "ACTG", "AcTg", and so on. Also note that, if double quotes (") are to be used in the match attribute, then the value " can be used in place of double quotes. Likewise, if single quotes (') are to be used in the match attribute, then the value ' can be used if necessary.
* ``level``: This works very similarly to the <exit_code> tag, except that, when a regular expression matches against its source, the description is added to the beginning of the source. For example, if stdout matches on a regular expression, then the regular expression's description is added to the beginning of stdout (instead of stderr). The level can be log, warning or fatal as described below.
 * ``log`` and ``warning``: If the regular expression matches against its source input (i.e., stdout and/or stderr), then a description of the error will be added to the beginning of the source, prepended with either 'Log:' or 'Warning:'. A log-level/warning-level error will not cause the tool to fail.
 * ``fatal``: If the regular expression matches against its source input, then a description of the error will be added to the beginning of the source. A fatal-level error will cause the tool to fail. If no level is specified, then the fatal error level will be assumed to have occurred.
* ``description``: Just like its ``exit_code`` counterpart, this is an optional description of the regular expression that has matched.

The following is an example of regular expressions that may be used:

```xml
<stdio>
    <regex match="low space"
           source="both"
           level="warning"
           description="Low space on device" />
    <regex match="error"
           source="stdout"
           level="fatal"
           description="Unknown error encountered" />
    <regex match="[CG]{12}"
           description="Fatal error - CG island 12 nts long found" />
    <regex match="^Branch A"
           level="warning"
           description="Branch A was taken in execution" />
</stdio>
```

The regular expression matching proceeds as follows. First, if either stdout or
stderr match on ``low space``, then a warning is registered. If stdout contained
the string ``---LOW SPACE---``, then stdout has the string ``Warning: Low space
on device`` added to its beginning. The same goes for if stderr had contained the
string ``low space``. Since only a warning could have occurred, the processing
continues.

Next, the regular expression ``error`` is matched only against stdout. If stdout
contains the string ``error`` regardless of its capitalization, then a fatal
error has occurred and the processing stops. In that case, stdout would be
prepended with the string ``Fatal: Unknown error encountered``. Note that, if
stderr contained ``error``, ``ERROR``, or ``ErRor`` then it would not matter -
stderr was not being scanned.

If the second regular expression did not match, then the third regular
expression is checked. The third regular expression does not contain an error
level, so an error level of ``fatal`` is assumed. The third regular expression
also does not contain a source, so both stdout and stderr are checked. The third
regular expression looks for 12 consecutive "C"s or "G"s in any order and in
uppercase or lowercase. If stdout contained ``cgccGGCCcGGcG`` or stderr
contained ``CCCCCCgggGGG``, then the regular expression would match, the tool
would be marked with a fatal error, and the stream that contained the
12-nucleotide CG island would be prepended with ``Fatal: Fatal error - CG island
12 nts long found``.

Finally, if the tool did not match any of the fatal errors, then the fourth
regular expression is checked. Since no source is specified, both stdout and
stderr are checked. If ``Branch A`` is at the beginning of stdout or stderr, then
a warning will be registered and the source that contained ``Branch A`` will be
prepended with the warning ``Warning: Branch A was taken in execution``.

]]></xs:documentation>
    </xs:annotation>
    <xs:attribute name="source" type="SourceType">
      <xs:annotation>
        <xs:documentation xml:lang="en">This tells whether the regular expression should be matched against stdout, stderr, or both. If this attribute is missing or is incorrect, then both stdout and stderr will be checked. The source can be one of the follwing values: </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="match" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">This is the regular expression that will be used to match against stdout and/or stderr. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="level" type="LevelType">
      <xs:annotation>
        <xs:documentation xml:lang="en">This works very similarly to the 'exit_code' tag, except that, when a regular expression matches against its source, the description is added to the beginning of the source.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">an optional description of the regular expression that has matched.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="ChangeFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[See
[extract_genomic_dna.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tools/extract_genomic_dna/extract_genomic_dna.xml)
or the test tool
[output_action_change_format.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/output_action_change_format.xml)
for simple examples of how this tag set is used in a tool. This tag set is
optionally contained within the ``<data>`` tag set and is the container tag set
for the following ``<when>`` tag set.]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="when" type="ChangeFormatWhen" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ChangeFormatWhen">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[

If the data type of the output dataset is the specified type, the data type is
changed to the desired type.

### Examples

Assume that your tool config includes the following select list parameter
structure:

```xml
<param name="out_format" type="select" label="Output data type">
    <option value="fasta">FASTA</option>
    <option value="interval">Interval</option>
</param>
```

Then whenever the user selects the ``interval`` option from the select list, the
following structure in your tool config will override the ``format="fasta"`` setting
in the ``<data>`` tag set with ``format="interval"``.

```xml
<outputs>
    <data format="fasta" name="out_file1">
        <change_format>
            <when input="out_format" value="interval" format="interval" />
        </change_format>
    </data>
</outputs>
```

See
[extract_genomic_dna.xml](https://github.com/galaxyproject/tools-iuc/blob/master/tools/extract_genomic_dna/extract_genomic_dna.xml)
or the test tool
[output_action_change_format.xml](https://github.com/galaxyproject/galaxy/blob/dev/test/functional/tools/output_action_change_format.xml)
for more examples.

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence/>
    <xs:attribute name="input" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must be the attribute name of
the desired input parameter (e.g. ``input="out_format"`` above).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must also be an attribute
name of an input parameter (e.g. ``value="interval"`` above).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="format" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">This value must be a supported data type
(e.g. ``format="interval"``). See
[/config/datatypes_conf.xml.sample](https://github.com/galaxyproject/galaxy/blob/dev/config/datatypes_conf.xml.sample)
for a list of supported formats.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Citations">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[Tool files may declare one
citations element. Each citations element can contain one or more citation tag
elements - each of which specifies tool citation information using either a DOI
or a BibTeX entry.

These citations will appear at the bottom of the tool form in a formatted way
but the user will have to option to select RAW BibTeX for copying and pasting as
well. Likewise, the history menu includes an option allowing users to aggregate
all such citations across an analysis in a list of citations.

BibTeX entries for citations annotated with DOIs will be fetched by Galaxy from
https://dx.doi.org/ and cached.

```xml
<citations>
   <!-- Example of annotating a citation using a DOI. -->
   <citation type="doi">10.1093/bioinformatics/btq281</citation>

   <!-- Example of annotating a citation using a BibTex entry. -->
   <citation type="bibtex">@ARTICLE{Kim07aninterior-point,
   author = {Seung-jean Kim and Kwangmoo Koh and Michael Lustig and Stephen Boyd and Dimitry Gorinevsky},
   title = {An interior-point method for large-scale l1-regularized logistic regression},
   journal = {Journal of Machine Learning Research},
   year = {2007},
   volume = {8},
   pages = {1519-1555}
   }</citation>
 </citations>
```

For more implementation information see the
[pull request](https://bitbucket.org/galaxy/galaxy-central/pull-requests/440/initial-bibtex-doi-citation-support-in/diff)
adding this feature. For more examples of how to add this to tools checkout the
following commits adding this to the
[NCBI BLAST+ suite](https://github.com/peterjc/galaxy_blast/commit/9d2e3906915895765ecc3f48421b91fabf2ccd8b),
[phenotype association tools](https://bitbucket.org/galaxy/galaxy-central/commits/39c983151fe328ff5d415f6da81ce5b21a7e18a4),
[MAF suite](https://bitbucket.org/galaxy/galaxy-central/commits/60f63d6d4cb7b73286f3c747e8acaa475e4b6fa8),
and [MACS2 suite](https://github.com/jmchilton/galaxytools/commit/184971dea73e236f11e82b77adb5cab615b8391b).

This feature was added to the August 2014 release of Galaxy, tools annotated
with citations will work in older releases of Galaxy but no citation information
will be available to the end user.
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="citation" type="Citation" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="Citation">
    <xs:annotation>
      <xs:documentation xml:lang="en">Each citations element can contain one or
more ``citation`` tag elements - each of which specifies tool citation
information using either a DOI or a BibTeX entry.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="type" type="CitationType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Type of citation - currently ``doi``
and ``bibtex`` are the only supported options.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="CitationType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Type of citation represented.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="bibtex"/>
      <xs:enumeration value="doi"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="RequirementType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for RequirementType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="python-module"/>
      <xs:enumeration value="binary"/>
      <xs:enumeration value="package"/>
      <xs:enumeration value="set_environment"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ContainerType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Type of container for tool execution.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="docker"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ToolTypeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ToolTypeType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="data_source"/>
      <xs:enumeration value="manage_data"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="URLmethodType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for URLmethodType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="get"/>
      <xs:enumeration value="post"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TargetType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for TargetType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="_top"/>
      <xs:enumeration value="_parent"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MethodType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for MethodType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="basic"/>
      <xs:enumeration value="multi"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DisplayType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for DisplayType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="checkboxes"/>
      <xs:enumeration value="radio"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HierarchyType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for HierarchyType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="exact"/>
      <xs:enumeration value="recurse"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ValidatorType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ValidatorType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="empty_dataset"/>
      <xs:enumeration value="expression"/>
      <xs:enumeration value="regex"/>
      <xs:enumeration value="in_range"/>
      <xs:enumeration value="length"/>
      <xs:enumeration value="metadata"/>
      <xs:enumeration value="unspecified_build"/>
      <xs:enumeration value="no_options"/>
      <xs:enumeration value="empty_field"/>
      <xs:enumeration value="dataset_metadata_in_file"/>
      <xs:enumeration value="dataset_metadata_in_data_table"/>
      <xs:enumeration value="dataset_ok_validator"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="FilterType">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="data_meta"/>
      <xs:enumeration value="param_value"/>
      <xs:enumeration value="static_value"/>
      <xs:enumeration value="unique_value"/>
      <xs:enumeration value="multiple_splitter"/>
      <xs:enumeration value="add_value"/>
      <xs:enumeration value="sort_by"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionsConditionalFilterType">
    <xs:annotation>
      <xs:documentation xml:lang="en"></xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="param_value"/>
      <xs:enumeration value="insert_column"/>
      <xs:enumeration value="column_strip"/>
      <xs:enumeration value="multiple_splitter"/>
      <xs:enumeration value="column_replace"/>
      <xs:enumeration value="metadata_value"/>
      <xs:enumeration value="boolean"/>
      <xs:enumeration value="string_function"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ActionType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="format"/>
      <xs:enumeration value="metadata"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionsOptionType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for ActionsOptionType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="from_data_table"/>
      <xs:enumeration value="from_param"/>
      <xs:enumeration value="from_file"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CompareType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for CompareType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="startswith"/>
      <xs:enumeration value="re_search"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LevelType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for LevelType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="fatal"/>
      <xs:enumeration value="warning"/>
      <xs:enumeration value="log"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="RangeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for RangeType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="\-?(\d)*:?\-?(\d)*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SourceType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for SourceType</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="stdout"/>
      <xs:enumeration value="stderr"/>
      <xs:enumeration value="both"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TestOutputCompareType">
    <xs:annotation>
      <xs:documentation xml:lang="en">Type of comparison to use when comparing
test generated output files to expected output files. Currently valid value are
``diff`` (the default), ``re_match``, ``sim_size``, ``re_match_multiline``,
and ``contains``.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="diff"/>
      <xs:enumeration value="re_match"/>
      <xs:enumeration value="sim_size"/>
      <xs:enumeration value="re_match_multiline"/>
      <xs:enumeration value="contains"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="PermissiveBoolean">
    <xs:annotation>
      <xs:documentation xml:lang="en">Documentation for PermissiveBoolean</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="0"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="true"/>
      <xs:enumeration value="false"/>
      <xs:enumeration value="True"/>
      <xs:enumeration value="False"/>
      <xs:enumeration value="yes"/>
      <xs:enumeration value="no"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="EdamTopics">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Container tag set for the ``<edam_topic>`` tags.
A tool can have any number of EDAM topic references.

```xml
   <!-- Example: this tool is about 'Statistics and probability' (http://edamontology.org/topic_2269) -->
  <edam_topics>
    <edam_topic>topic_2269</edam_topic>
  </edam_topics>
```
]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="edam_topic" minOccurs="0" maxOccurs="unbounded">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:pattern value="topic_[0-9]{4}"></xs:pattern>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="EdamOperations">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Container tag set for the ``<edam_operation>`` tags.
A tool can have any number of EDAM operation references.

```xml
  <!-- Example: this tool performs a 'Conversion' operation (http://edamontology.org/operation_3434) -->
  <edam_operations>
    <edam_operation>operation_3434</edam_operation>
  </edam_operations>
```

]]></xs:documentation>
    </xs:annotation>
    <xs:sequence>
        <xs:element name="edam_operation" minOccurs="0" maxOccurs="unbounded">
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:pattern value="operation_[0-9]{4}"></xs:pattern>
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>

</xs:schema>
